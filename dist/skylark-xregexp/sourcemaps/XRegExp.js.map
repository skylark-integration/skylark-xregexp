{"version":3,"sources":["XRegExp.js"],"names":["define","REGEX_DATA","features","astral","namespacing","nativ","exec","RegExp","prototype","test","match","String","replace","split","fixed","regexCache","patternCache","tokens","defaultScope","classScope","nativeTokens","default","class","replacementToken","correctExecNpcg","undefined","call","hasFlagsProp","flags","toString","hasNativeFlag","flag","isSupported","exception","hasNativeU","hasNativeY","registeredFlags","g","i","m","u","y","augment","regex","captureNames","xSource","xFlags","isInternalOnly","__proto__","XRegExp","p","source","sort","join","clipDuplicates","str","copyRegex","options","isRegExp","TypeError","xData","getNativeFlags","flagsToAdd","flagsToRemove","xregexpSource","xregexpFlags","removeG","removeY","addG","addY","hasNamedCapture","slice","dec","hex","parseInt","getContextualTokenSeparator","scope","input","index","length","substr","pattern","pos","includes","isQuantifierNext","isType","value","type","pad4","prepareOptions","forEach","registerFlag","Error","runTokens","context","leadChar","t","result","matchLength","output","handler","reparse","setAstral","on","setNamespacing","toObject","isInstalled","applied","SyntaxError","$0","$1","prepareFlags","appliedPattern","appliedFlags","token","captures","generated","version","_clipDuplicates","_hasNativeFlag","_dec","_hex","_pad4","addToken","optionalFlags","push","cache","flush","cacheName","escape","sticky","cacheKey","fakeY","r2","lastIndex","pop","global","callback","globalize","install","feature","matchChain","chain","recurseChain","values","level","item","matches","addMatch","backref","ERR_UNDEFINED_GROUP","isNamedBackref","isNaN","groups","ReferenceError","hasOwnProperty","backrefValue","search","replacement","isRegex","s2","replaceEach","replacements","r","separator","limit","uninstall","union","patterns","conjunction","numPriorCaptures","numCaptures","rewrite","paren","name","parts","origLastIndex","this","apply","arguments","args","len","groupsObject","Object","create","bracketed","angled","dollarToken","n","indexOf","lastLength","lastLastIndex","Array","code","endIndex"],"mappings":"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","file":"../XRegExp.js","sourcesContent":["define([],function(){\n\n    // Property name used for extended regex instance data\n    const REGEX_DATA = 'xregexp';\n    // Optional features that can be installed and uninstalled\n    const features = {\n        astral: false,\n        namespacing: false\n    };\n    // Native methods to use and restore ('native' is an ES3 reserved keyword)\n    const nativ = {\n        exec: RegExp.prototype.exec,\n        test: RegExp.prototype.test,\n        match: String.prototype.match,\n        replace: String.prototype.replace,\n        split: String.prototype.split\n    };\n    // Storage for fixed/extended native methods\n    const fixed = {};\n    // Storage for regexes cached by `XRegExp.cache`\n    let regexCache = {};\n    // Storage for pattern details cached by the `XRegExp` constructor\n    let patternCache = {};\n    // Storage for regex syntax tokens added internally or by `XRegExp.addToken`\n    const tokens = [];\n    // Token scopes\n    const defaultScope = 'default';\n    const classScope = 'class';\n    // Regexes that match native regex syntax, including octals\n    const nativeTokens = {\n        // Any native multicharacter token in default scope, or any single character\n        'default': /\\\\(?:0(?:[0-3][0-7]{0,2}|[4-7][0-7]?)?|[1-9]\\d*|x[\\dA-Fa-f]{2}|u(?:[\\dA-Fa-f]{4}|{[\\dA-Fa-f]+})|c[A-Za-z]|[\\s\\S])|\\(\\?(?:[:=!]|<[=!])|[?*+]\\?|{\\d+(?:,\\d*)?}\\??|[\\s\\S]/,\n        // Any native multicharacter token in character class scope, or any single character\n        'class': /\\\\(?:[0-3][0-7]{0,2}|[4-7][0-7]?|x[\\dA-Fa-f]{2}|u(?:[\\dA-Fa-f]{4}|{[\\dA-Fa-f]+})|c[A-Za-z]|[\\s\\S])|[\\s\\S]/\n    };\n    // Any backreference or dollar-prefixed character in replacement strings\n    const replacementToken = /\\$(?:{([\\w$]+)}|<([\\w$]+)>|(\\d\\d?|[\\s\\S]))/g;\n    // Check for correct `exec` handling of nonparticipating capturing groups\n    const correctExecNpcg = nativ.exec.call(/()??/, '')[1] === undefined;\n    // Check for ES6 `flags` prop support\n    const hasFlagsProp = /x/.flags !== undefined;\n    // Shortcut to `Object.prototype.toString`\n    const {toString} = {};\n\n    function hasNativeFlag(flag) {\n        // Can't check based on the presence of properties/getters since browsers might support such\n        // properties even when they don't support the corresponding flag in regex construction (tested\n        // in Chrome 48, where `'unicode' in /x/` is true but trying to construct a regex with flag `u`\n        // throws an error)\n        let isSupported = true;\n        try {\n            // Can't use regex literals for testing even in a `try` because regex literals with\n            // unsupported flags cause a compilation error in IE\n            new RegExp('', flag);\n        } catch (exception) {\n            isSupported = false;\n        }\n        return isSupported;\n    }\n    // Check for ES6 `u` flag support\n    const hasNativeU = hasNativeFlag('u');\n    // Check for ES6 `y` flag support\n    const hasNativeY = hasNativeFlag('y');\n    // Tracker for known flags, including addon flags\n    const registeredFlags = {\n        g: true,\n        i: true,\n        m: true,\n        u: hasNativeU,\n        y: hasNativeY\n    };\n\n    /**\n     * Attaches extended data and `XRegExp.prototype` properties to a regex object.\n     *\n     * @private\n     * @param {RegExp} regex Regex to augment.\n     * @param {Array} captureNames Array with capture names, or `null`.\n     * @param {String} xSource XRegExp pattern used to generate `regex`, or `null` if N/A.\n     * @param {String} xFlags XRegExp flags used to generate `regex`, or `null` if N/A.\n     * @param {Boolean} [isInternalOnly=false] Whether the regex will be used only for internal\n     *   operations, and never exposed to users. For internal-only regexes, we can improve perf by\n     *   skipping some operations like attaching `XRegExp.prototype` properties.\n     * @returns {RegExp} Augmented regex.\n     */\n    function augment(regex, captureNames, xSource, xFlags, isInternalOnly) {\n        regex[REGEX_DATA] = {\n            captureNames\n        };\n\n        if (isInternalOnly) {\n            return regex;\n        }\n\n        // Can't auto-inherit these since the XRegExp constructor returns a nonprimitive value\n        if (regex.__proto__) {\n            regex.__proto__ = XRegExp.prototype;\n        } else {\n            for (const p in XRegExp.prototype) {\n                // An `XRegExp.prototype.hasOwnProperty(p)` check wouldn't be worth it here, since this\n                // is performance sensitive, and enumerable `Object.prototype` or `RegExp.prototype`\n                // extensions exist on `regex.prototype` anyway\n                regex[p] = XRegExp.prototype[p];\n            }\n        }\n\n        regex[REGEX_DATA].source = xSource;\n        // Emulate the ES6 `flags` prop by ensuring flags are in alphabetical order\n        regex[REGEX_DATA].flags = xFlags ? xFlags.split('').sort().join('') : xFlags;\n\n        return regex;\n    }\n\n    /**\n     * Removes any duplicate characters from the provided string.\n     *\n     * @private\n     * @param {String} str String to remove duplicate characters from.\n     * @returns {String} String with any duplicate characters removed.\n     */\n    function clipDuplicates(str) {\n        return nativ.replace.call(str, /([\\s\\S])(?=[\\s\\S]*\\1)/g, '');\n    }\n\n    /**\n     * Copies a regex object while preserving extended data and augmenting with `XRegExp.prototype`\n     * properties. The copy has a fresh `lastIndex` property (set to zero). Allows adding and removing\n     * flags g and y while copying the regex.\n     *\n     * @private\n     * @param {RegExp} regex Regex to copy.\n     * @param {Object} [options] Options object with optional properties:\n     *   - `addG` {Boolean} Add flag g while copying the regex.\n     *   - `addY` {Boolean} Add flag y while copying the regex.\n     *   - `removeG` {Boolean} Remove flag g while copying the regex.\n     *   - `removeY` {Boolean} Remove flag y while copying the regex.\n     *   - `isInternalOnly` {Boolean} Whether the copied regex will be used only for internal\n     *     operations, and never exposed to users. For internal-only regexes, we can improve perf by\n     *     skipping some operations like attaching `XRegExp.prototype` properties.\n     *   - `source` {String} Overrides `<regex>.source`, for special cases.\n     * @returns {RegExp} Copy of the provided regex, possibly with modified flags.\n     */\n    function copyRegex(regex, options) {\n        if (!XRegExp.isRegExp(regex)) {\n            throw new TypeError('Type RegExp expected');\n        }\n\n        const xData = regex[REGEX_DATA] || {};\n        let flags = getNativeFlags(regex);\n        let flagsToAdd = '';\n        let flagsToRemove = '';\n        let xregexpSource = null;\n        let xregexpFlags = null;\n\n        options = options || {};\n\n        if (options.removeG) {flagsToRemove += 'g';}\n        if (options.removeY) {flagsToRemove += 'y';}\n        if (flagsToRemove) {\n            flags = nativ.replace.call(flags, new RegExp(`[${flagsToRemove}]+`, 'g'), '');\n        }\n\n        if (options.addG) {flagsToAdd += 'g';}\n        if (options.addY) {flagsToAdd += 'y';}\n        if (flagsToAdd) {\n            flags = clipDuplicates(flags + flagsToAdd);\n        }\n\n        if (!options.isInternalOnly) {\n            if (xData.source !== undefined) {\n                xregexpSource = xData.source;\n            }\n            // null or undefined; don't want to add to `flags` if the previous value was null, since\n            // that indicates we're not tracking original precompilation flags\n            if (xData.flags != null) {\n                // Flags are only added for non-internal regexes by `XRegExp.globalize`. Flags are never\n                // removed for non-internal regexes, so don't need to handle it\n                xregexpFlags = flagsToAdd ? clipDuplicates(xData.flags + flagsToAdd) : xData.flags;\n            }\n        }\n\n        // Augment with `XRegExp.prototype` properties, but use the native `RegExp` constructor to avoid\n        // searching for special tokens. That would be wrong for regexes constructed by `RegExp`, and\n        // unnecessary for regexes constructed by `XRegExp` because the regex has already undergone the\n        // translation to native regex syntax\n        regex = augment(\n            new RegExp(options.source || regex.source, flags),\n            hasNamedCapture(regex) ? xData.captureNames.slice(0) : null,\n            xregexpSource,\n            xregexpFlags,\n            options.isInternalOnly\n        );\n\n        return regex;\n    }\n\n    /**\n     * Converts hexadecimal to decimal.\n     *\n     * @private\n     * @param {String} hex\n     * @returns {Number}\n     */\n    function dec(hex) {\n        return parseInt(hex, 16);\n    }\n\n    /**\n     * Returns a pattern that can be used in a native RegExp in place of an ignorable token such as an\n     * inline comment or whitespace with flag x. This is used directly as a token handler function\n     * passed to `XRegExp.addToken`.\n     *\n     * @private\n     * @param {String} match Match arg of `XRegExp.addToken` handler\n     * @param {String} scope Scope arg of `XRegExp.addToken` handler\n     * @param {String} flags Flags arg of `XRegExp.addToken` handler\n     * @returns {String} Either '' or '(?:)', depending on which is needed in the context of the match.\n     */\n    function getContextualTokenSeparator(match, scope, flags) {\n        if (\n            // No need to separate tokens if at the beginning or end of a group\n            match.input[match.index - 1] === '(' ||\n            match.input[match.index + match[0].length] === ')' ||\n\n            // No need to separate tokens if before or after a `|`\n            match.input[match.index - 1] === '|' ||\n            match.input[match.index + match[0].length] === '|' ||\n\n            // No need to separate tokens if at the beginning or end of the pattern\n            match.index < 1 ||\n            match.index + match[0].length >= match.input.length ||\n\n            // No need to separate tokens if at the beginning of a noncapturing group or lookahead.\n            // The way this is written relies on:\n            // - The search regex matching only 3-char strings.\n            // - Although `substr` gives chars from the end of the string if given a negative index,\n            //   the resulting substring will be too short to match. Ex: `'abcd'.substr(-1, 3) === 'd'`\n            nativ.test.call(/^\\(\\?[:=!]/, match.input.substr(match.index - 3, 3)) ||\n\n            // Avoid separating tokens when the following token is a quantifier\n            isQuantifierNext(match.input, match.index + match[0].length, flags)\n        ) {\n            return '';\n        }\n        // Keep tokens separated. This avoids e.g. inadvertedly changing `\\1 1` or `\\1(?#)1` to `\\11`.\n        // This also ensures all tokens remain as discrete atoms, e.g. it avoids converting the syntax\n        // error `(? :` into `(?:`.\n        return '(?:)';\n    }\n\n    /**\n     * Returns native `RegExp` flags used by a regex object.\n     *\n     * @private\n     * @param {RegExp} regex Regex to check.\n     * @returns {String} Native flags in use.\n     */\n    function getNativeFlags(regex) {\n        return hasFlagsProp ?\n            regex.flags :\n            // Explicitly using `RegExp.prototype.toString` (rather than e.g. `String` or concatenation\n            // with an empty string) allows this to continue working predictably when\n            // `XRegExp.proptotype.toString` is overridden\n            nativ.exec.call(/\\/([a-z]*)$/i, RegExp.prototype.toString.call(regex))[1];\n    }\n\n    /**\n     * Determines whether a regex has extended instance data used to track capture names.\n     *\n     * @private\n     * @param {RegExp} regex Regex to check.\n     * @returns {Boolean} Whether the regex uses named capture.\n     */\n    function hasNamedCapture(regex) {\n        return !!(regex[REGEX_DATA] && regex[REGEX_DATA].captureNames);\n    }\n\n    /**\n     * Converts decimal to hexadecimal.\n     *\n     * @private\n     * @param {Number|String} dec\n     * @returns {String}\n     */\n    function hex(dec) {\n        return parseInt(dec, 10).toString(16);\n    }\n\n    /**\n     * Checks whether the next nonignorable token after the specified position is a quantifier.\n     *\n     * @private\n     * @param {String} pattern Pattern to search within.\n     * @param {Number} pos Index in `pattern` to search at.\n     * @param {String} flags Flags used by the pattern.\n     * @returns {Boolean} Whether the next nonignorable token is a quantifier.\n     */\n    function isQuantifierNext(pattern, pos, flags) {\n        const inlineCommentPattern = '\\\\(\\\\?#[^)]*\\\\)';\n        const lineCommentPattern = '#[^#\\\\n]*';\n        const quantifierPattern = '[?*+]|{\\\\d+(?:,\\\\d*)?}';\n        return nativ.test.call(\n            flags.includes('x') ?\n                // Ignore any leading whitespace, line comments, and inline comments\n                new RegExp(`^(?:\\\\s|${lineCommentPattern}|${inlineCommentPattern})*(?:${quantifierPattern})`) :\n                // Ignore any leading inline comments\n                new RegExp(`^(?:${inlineCommentPattern})*(?:${quantifierPattern})`),\n            pattern.slice(pos)\n        );\n    }\n\n    /**\n     * Determines whether a value is of the specified type, by resolving its internal [[Class]].\n     *\n     * @private\n     * @param {*} value Object to check.\n     * @param {String} type Type to check for, in TitleCase.\n     * @returns {Boolean} Whether the object matches the type.\n     */\n    function isType(value, type) {\n        return toString.call(value) === `[object ${type}]`;\n    }\n\n    /**\n     * Adds leading zeros if shorter than four characters. Used for fixed-length hexadecimal values.\n     *\n     * @private\n     * @param {String} str\n     * @returns {String}\n     */\n    function pad4(str) {\n        while (str.length < 4) {\n            str = `0${str}`;\n        }\n        return str;\n    }\n\n    /**\n     * Checks for flag-related errors, and strips/applies flags in a leading mode modifier. Offloads\n     * the flag preparation logic from the `XRegExp` constructor.\n     *\n     * @private\n     * @param {String} pattern Regex pattern, possibly with a leading mode modifier.\n     * @param {String} flags Any combination of flags.\n     * @returns {Object} Object with properties `pattern` and `flags`.\n     */\n    function prepareFlags(pattern, flags) {\n        // Recent browsers throw on duplicate flags, so copy this behavior for nonnative flags\n        if (clipDuplicates(flags) !== flags) {\n            throw new SyntaxError(`Invalid duplicate regex flag ${flags}`);\n        }\n\n        // Strip and apply a leading mode modifier with any combination of flags except g or y\n        pattern = nativ.replace.call(pattern, /^\\(\\?([\\w$]+)\\)/, ($0, $1) => {\n            if (nativ.test.call(/[gy]/, $1)) {\n                throw new SyntaxError(`Cannot use flag g or y in mode modifier ${$0}`);\n            }\n            // Allow duplicate flags within the mode modifier\n            flags = clipDuplicates(flags + $1);\n            return '';\n        });\n\n        // Throw on unknown native or nonnative flags\n        for (const flag of flags) {\n            if (!registeredFlags[flag]) {\n                throw new SyntaxError(`Unknown regex flag ${flag}`);\n            }\n        }\n\n        return {\n            pattern,\n            flags\n        };\n    }\n\n    /**\n     * Prepares an options object from the given value.\n     *\n     * @private\n     * @param {String|Object} value Value to convert to an options object.\n     * @returns {Object} Options object.\n     */\n    function prepareOptions(value) {\n        const options = {};\n\n        if (isType(value, 'String')) {\n            XRegExp.forEach(value, /[^\\s,]+/, (match) => {\n                options[match] = true;\n            });\n\n            return options;\n        }\n\n        return value;\n    }\n\n    /**\n     * Registers a flag so it doesn't throw an 'unknown flag' error.\n     *\n     * @private\n     * @param {String} flag Single-character flag to register.\n     */\n    function registerFlag(flag) {\n        if (!/^[\\w$]$/.test(flag)) {\n            throw new Error('Flag must be a single character A-Za-z0-9_$');\n        }\n\n        registeredFlags[flag] = true;\n    }\n\n    /**\n     * Runs built-in and custom regex syntax tokens in reverse insertion order at the specified\n     * position, until a match is found.\n     *\n     * @private\n     * @param {String} pattern Original pattern from which an XRegExp object is being built.\n     * @param {String} flags Flags being used to construct the regex.\n     * @param {Number} pos Position to search for tokens within `pattern`.\n     * @param {Number} scope Regex scope to apply: 'default' or 'class'.\n     * @param {Object} context Context object to use for token handler functions.\n     * @returns {Object} Object with properties `matchLength`, `output`, and `reparse`; or `null`.\n     */\n    function runTokens(pattern, flags, pos, scope, context) {\n        let i = tokens.length;\n        const leadChar = pattern[pos];\n        let result = null;\n        let match;\n        let t;\n\n        // Run in reverse insertion order\n        while (i--) {\n            t = tokens[i];\n            if (\n                (t.leadChar && t.leadChar !== leadChar) ||\n                (t.scope !== scope && t.scope !== 'all') ||\n                (t.flag && !flags.includes(t.flag))\n            ) {\n                continue;\n            }\n\n            match = XRegExp.exec(pattern, t.regex, pos, 'sticky');\n            if (match) {\n                result = {\n                    matchLength: match[0].length,\n                    output: t.handler.call(context, match, scope, flags),\n                    reparse: t.reparse\n                };\n                // Finished with token tests\n                break;\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * Enables or disables implicit astral mode opt-in. When enabled, flag A is automatically added to\n     * all new regexes created by XRegExp. This causes an error to be thrown when creating regexes if\n     * the Unicode Base addon is not available, since flag A is registered by that addon.\n     *\n     * @private\n     * @param {Boolean} on `true` to enable; `false` to disable.\n     */\n    function setAstral(on) {\n        features.astral = on;\n    }\n\n    /**\n     * Adds named capture groups to the `groups` property of match arrays. See here for details:\n     * https://github.com/tc39/proposal-regexp-named-groups\n     *\n     * @private\n     * @param {Boolean} on `true` to enable; `false` to disable.\n     */\n    function setNamespacing(on) {\n        features.namespacing = on;\n    }\n\n    /**\n     * Returns the object, or throws an error if it is `null` or `undefined`. This is used to follow\n     * the ES5 abstract operation `ToObject`.\n     *\n     * @private\n     * @param {*} value Object to check and return.\n     * @returns {*} The provided object.\n     */\n    function toObject(value) {\n        // null or undefined\n        if (value == null) {\n            throw new TypeError('Cannot convert null or undefined to object');\n        }\n\n        return value;\n    }\n\n    // ==--------------------------==\n    // Constructor\n    // ==--------------------------==\n\n    /**\n     * Creates an extended regular expression object for matching text with a pattern. Differs from a\n     * native regular expression in that additional syntax and flags are supported. The returned object\n     * is in fact a native `RegExp` and works with all native methods.\n     *\n     * @class XRegExp\n     * @constructor\n     * @param {String|RegExp} pattern Regex pattern string, or an existing regex object to copy.\n     * @param {String} [flags] Any combination of flags.\n     *   Native flags:\n     *     - `g` - global\n     *     - `i` - ignore case\n     *     - `m` - multiline anchors\n     *     - `u` - unicode (ES6)\n     *     - `y` - sticky (Firefox 3+, ES6)\n     *   Additional XRegExp flags:\n     *     - `n` - explicit capture\n     *     - `s` - dot matches all (aka singleline)\n     *     - `x` - free-spacing and line comments (aka extended)\n     *     - `A` - astral (requires the Unicode Base addon)\n     *   Flags cannot be provided when constructing one `RegExp` from another.\n     * @returns {RegExp} Extended regular expression object.\n     * @example\n     *\n     * // With named capture and flag x\n     * XRegExp(`(?<year>  [0-9]{4} ) -?  # year\n     *          (?<month> [0-9]{2} ) -?  # month\n     *          (?<day>   [0-9]{2} )     # day`, 'x');\n     *\n     * // Providing a regex object copies it. Native regexes are recompiled using native (not XRegExp)\n     * // syntax. Copies maintain extended data, are augmented with `XRegExp.prototype` properties, and\n     * // have fresh `lastIndex` properties (set to zero).\n     * XRegExp(/regex/);\n     */\n    function XRegExp(pattern, flags) {\n        if (XRegExp.isRegExp(pattern)) {\n            if (flags !== undefined) {\n                throw new TypeError('Cannot supply flags when copying a RegExp');\n            }\n            return copyRegex(pattern);\n        }\n\n        // Copy the argument behavior of `RegExp`\n        pattern = pattern === undefined ? '' : String(pattern);\n        flags = flags === undefined ? '' : String(flags);\n\n        if (XRegExp.isInstalled('astral') && !flags.includes('A')) {\n            // This causes an error to be thrown if the Unicode Base addon is not available\n            flags += 'A';\n        }\n\n        if (!patternCache[pattern]) {\n            patternCache[pattern] = {};\n        }\n\n        if (!patternCache[pattern][flags]) {\n            const context = {\n                hasNamedCapture: false,\n                captureNames: []\n            };\n            let scope = defaultScope;\n            let output = '';\n            let pos = 0;\n            let result;\n\n            // Check for flag-related errors, and strip/apply flags in a leading mode modifier\n            const applied = prepareFlags(pattern, flags);\n            let appliedPattern = applied.pattern;\n            const appliedFlags = applied.flags;\n\n            // Use XRegExp's tokens to translate the pattern to a native regex pattern.\n            // `appliedPattern.length` may change on each iteration if tokens use `reparse`\n            while (pos < appliedPattern.length) {\n                do {\n                    // Check for custom tokens at the current position\n                    result = runTokens(appliedPattern, appliedFlags, pos, scope, context);\n                    // If the matched token used the `reparse` option, splice its output into the\n                    // pattern before running tokens again at the same position\n                    if (result && result.reparse) {\n                        appliedPattern = appliedPattern.slice(0, pos) +\n                            result.output +\n                            appliedPattern.slice(pos + result.matchLength);\n                    }\n                } while (result && result.reparse);\n\n                if (result) {\n                    output += result.output;\n                    pos += (result.matchLength || 1);\n                } else {\n                    // Get the native token at the current position\n                    const [token] = XRegExp.exec(appliedPattern, nativeTokens[scope], pos, 'sticky');\n                    output += token;\n                    pos += token.length;\n                    if (token === '[' && scope === defaultScope) {\n                        scope = classScope;\n                    } else if (token === ']' && scope === classScope) {\n                        scope = defaultScope;\n                    }\n                }\n            }\n\n            patternCache[pattern][flags] = {\n                // Use basic cleanup to collapse repeated empty groups like `(?:)(?:)` to `(?:)`. Empty\n                // groups are sometimes inserted during regex transpilation in order to keep tokens\n                // separated. However, more than one empty group in a row is never needed.\n                pattern: nativ.replace.call(output, /(?:\\(\\?:\\))+/g, '(?:)'),\n                // Strip all but native flags\n                flags: nativ.replace.call(appliedFlags, /[^gimuy]+/g, ''),\n                // `context.captureNames` has an item for each capturing group, even if unnamed\n                captures: context.hasNamedCapture ? context.captureNames : null\n            };\n        }\n\n        const generated = patternCache[pattern][flags];\n        return augment(\n            new RegExp(generated.pattern, generated.flags),\n            generated.captures,\n            pattern,\n            flags\n        );\n    }\n\n    // Add `RegExp.prototype` to the prototype chain\n    XRegExp.prototype = new RegExp();\n\n    // ==--------------------------==\n    // Public properties\n    // ==--------------------------==\n\n    /**\n     * The XRegExp version number as a string containing three dot-separated parts. For example,\n     * '2.0.0-beta-3'.\n     *\n     * @static\n     * @memberOf XRegExp\n     * @type String\n     */\n    XRegExp.version = '4.2.4';\n\n    // ==--------------------------==\n    // Public methods\n    // ==--------------------------==\n\n    // Intentionally undocumented; used in tests and addons\n    XRegExp._clipDuplicates = clipDuplicates;\n    XRegExp._hasNativeFlag = hasNativeFlag;\n    XRegExp._dec = dec;\n    XRegExp._hex = hex;\n    XRegExp._pad4 = pad4;\n\n    /**\n     * Extends XRegExp syntax and allows custom flags. This is used internally and can be used to\n     * create XRegExp addons. If more than one token can match the same string, the last added wins.\n     *\n     * @memberOf XRegExp\n     * @param {RegExp} regex Regex object that matches the new token.\n     * @param {Function} handler Function that returns a new pattern string (using native regex syntax)\n     *   to replace the matched token within all future XRegExp regexes. Has access to persistent\n     *   properties of the regex being built, through `this`. Invoked with three arguments:\n     *   - The match array, with named backreference properties.\n     *   - The regex scope where the match was found: 'default' or 'class'.\n     *   - The flags used by the regex, including any flags in a leading mode modifier.\n     *   The handler function becomes part of the XRegExp construction process, so be careful not to\n     *   construct XRegExps within the function or you will trigger infinite recursion.\n     * @param {Object} [options] Options object with optional properties:\n     *   - `scope` {String} Scope where the token applies: 'default', 'class', or 'all'.\n     *   - `flag` {String} Single-character flag that triggers the token. This also registers the\n     *     flag, which prevents XRegExp from throwing an 'unknown flag' error when the flag is used.\n     *   - `optionalFlags` {String} Any custom flags checked for within the token `handler` that are\n     *     not required to trigger the token. This registers the flags, to prevent XRegExp from\n     *     throwing an 'unknown flag' error when any of the flags are used.\n     *   - `reparse` {Boolean} Whether the `handler` function's output should not be treated as\n     *     final, and instead be reparseable by other tokens (including the current token). Allows\n     *     token chaining or deferring.\n     *   - `leadChar` {String} Single character that occurs at the beginning of any successful match\n     *     of the token (not always applicable). This doesn't change the behavior of the token unless\n     *     you provide an erroneous value. However, providing it can increase the token's performance\n     *     since the token can be skipped at any positions where this character doesn't appear.\n     * @example\n     *\n     * // Basic usage: Add \\a for the ALERT control code\n     * XRegExp.addToken(\n     *   /\\\\a/,\n     *   () => '\\\\x07',\n     *   {scope: 'all'}\n     * );\n     * XRegExp('\\\\a[\\\\a-\\\\n]+').test('\\x07\\n\\x07'); // -> true\n     *\n     * // Add the U (ungreedy) flag from PCRE and RE2, which reverses greedy and lazy quantifiers.\n     * // Since `scope` is not specified, it uses 'default' (i.e., transformations apply outside of\n     * // character classes only)\n     * XRegExp.addToken(\n     *   /([?*+]|{\\d+(?:,\\d*)?})(\\??)/,\n     *   (match) => `${match[1]}${match[2] ? '' : '?'}`,\n     *   {flag: 'U'}\n     * );\n     * XRegExp('a+', 'U').exec('aaa')[0]; // -> 'a'\n     * XRegExp('a+?', 'U').exec('aaa')[0]; // -> 'aaa'\n     */\n    XRegExp.addToken = (regex, handler, options) => {\n        options = options || {};\n        let {optionalFlags} = options;\n\n        if (options.flag) {\n            registerFlag(options.flag);\n        }\n\n        if (optionalFlags) {\n            optionalFlags = nativ.split.call(optionalFlags, '');\n            for (const flag of optionalFlags) {\n                registerFlag(flag);\n            }\n        }\n\n        // Add to the private list of syntax tokens\n        tokens.push({\n            regex: copyRegex(regex, {\n                addG: true,\n                addY: hasNativeY,\n                isInternalOnly: true\n            }),\n            handler,\n            scope: options.scope || defaultScope,\n            flag: options.flag,\n            reparse: options.reparse,\n            leadChar: options.leadChar\n        });\n\n        // Reset the pattern cache used by the `XRegExp` constructor, since the same pattern and flags\n        // might now produce different results\n        XRegExp.cache.flush('patterns');\n    };\n\n    /**\n     * Caches and returns the result of calling `XRegExp(pattern, flags)`. On any subsequent call with\n     * the same pattern and flag combination, the cached copy of the regex is returned.\n     *\n     * @memberOf XRegExp\n     * @param {String} pattern Regex pattern string.\n     * @param {String} [flags] Any combination of XRegExp flags.\n     * @returns {RegExp} Cached XRegExp object.\n     * @example\n     *\n     * while (match = XRegExp.cache('.', 'gs').exec(str)) {\n     *   // The regex is compiled once only\n     * }\n     */\n    XRegExp.cache = (pattern, flags) => {\n        if (!regexCache[pattern]) {\n            regexCache[pattern] = {};\n        }\n        return regexCache[pattern][flags] || (\n            regexCache[pattern][flags] = XRegExp(pattern, flags)\n        );\n    };\n\n    // Intentionally undocumented; used in tests\n    XRegExp.cache.flush = (cacheName) => {\n        if (cacheName === 'patterns') {\n            // Flush the pattern cache used by the `XRegExp` constructor\n            patternCache = {};\n        } else {\n            // Flush the regex cache populated by `XRegExp.cache`\n            regexCache = {};\n        }\n    };\n\n    /**\n     * Escapes any regular expression metacharacters, for use when matching literal strings. The result\n     * can safely be used at any point within a regex that uses any flags.\n     *\n     * @memberOf XRegExp\n     * @param {String} str String to escape.\n     * @returns {String} String with regex metacharacters escaped.\n     * @example\n     *\n     * XRegExp.escape('Escaped? <.>');\n     * // -> 'Escaped\\?\\ <\\.>'\n     */\n    XRegExp.escape = (str) => nativ.replace.call(toObject(str), /[-\\[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&');\n\n    /**\n     * Executes a regex search in a specified string. Returns a match array or `null`. If the provided\n     * regex uses named capture, named backreference properties are included on the match array.\n     * Optional `pos` and `sticky` arguments specify the search start position, and whether the match\n     * must start at the specified position only. The `lastIndex` property of the provided regex is not\n     * used, but is updated for compatibility. Also fixes browser bugs compared to the native\n     * `RegExp.prototype.exec` and can be used reliably cross-browser.\n     *\n     * @memberOf XRegExp\n     * @param {String} str String to search.\n     * @param {RegExp} regex Regex to search with.\n     * @param {Number} [pos=0] Zero-based index at which to start the search.\n     * @param {Boolean|String} [sticky=false] Whether the match must start at the specified position\n     *   only. The string `'sticky'` is accepted as an alternative to `true`.\n     * @returns {Array} Match array with named backreference properties, or `null`.\n     * @example\n     *\n     * // Basic use, with named backreference\n     * let match = XRegExp.exec('U+2620', XRegExp('U\\\\+(?<hex>[0-9A-F]{4})'));\n     * match.hex; // -> '2620'\n     *\n     * // With pos and sticky, in a loop\n     * let pos = 2, result = [], match;\n     * while (match = XRegExp.exec('<1><2><3><4>5<6>', /<(\\d)>/, pos, 'sticky')) {\n     *   result.push(match[1]);\n     *   pos = match.index + match[0].length;\n     * }\n     * // result -> ['2', '3', '4']\n     */\n    XRegExp.exec = (str, regex, pos, sticky) => {\n        let cacheKey = 'g';\n        let addY = false;\n        let fakeY = false;\n        let match;\n\n        addY = hasNativeY && !!(sticky || (regex.sticky && sticky !== false));\n        if (addY) {\n            cacheKey += 'y';\n        } else if (sticky) {\n            // Simulate sticky matching by appending an empty capture to the original regex. The\n            // resulting regex will succeed no matter what at the current index (set with `lastIndex`),\n            // and will not search the rest of the subject string. We'll know that the original regex\n            // has failed if that last capture is `''` rather than `undefined` (i.e., if that last\n            // capture participated in the match).\n            fakeY = true;\n            cacheKey += 'FakeY';\n        }\n\n        regex[REGEX_DATA] = regex[REGEX_DATA] || {};\n\n        // Shares cached copies with `XRegExp.match`/`replace`\n        const r2 = regex[REGEX_DATA][cacheKey] || (\n            regex[REGEX_DATA][cacheKey] = copyRegex(regex, {\n                addG: true,\n                addY,\n                source: fakeY ? `${regex.source}|()` : undefined,\n                removeY: sticky === false,\n                isInternalOnly: true\n            })\n        );\n\n        pos = pos || 0;\n        r2.lastIndex = pos;\n\n        // Fixed `exec` required for `lastIndex` fix, named backreferences, etc.\n        match = fixed.exec.call(r2, str);\n\n        // Get rid of the capture added by the pseudo-sticky matcher if needed. An empty string means\n        // the original regexp failed (see above).\n        if (fakeY && match && match.pop() === '') {\n            match = null;\n        }\n\n        if (regex.global) {\n            regex.lastIndex = match ? r2.lastIndex : 0;\n        }\n\n        return match;\n    };\n\n    /**\n     * Executes a provided function once per regex match. Searches always start at the beginning of the\n     * string and continue until the end, regardless of the state of the regex's `global` property and\n     * initial `lastIndex`.\n     *\n     * @memberOf XRegExp\n     * @param {String} str String to search.\n     * @param {RegExp} regex Regex to search with.\n     * @param {Function} callback Function to execute for each match. Invoked with four arguments:\n     *   - The match array, with named backreference properties.\n     *   - The zero-based match index.\n     *   - The string being traversed.\n     *   - The regex object being used to traverse the string.\n     * @example\n     *\n     * // Extracts every other digit from a string\n     * const evens = [];\n     * XRegExp.forEach('1a2345', /\\d/, (match, i) => {\n     *   if (i % 2) evens.push(+match[0]);\n     * });\n     * // evens -> [2, 4]\n     */\n    XRegExp.forEach = (str, regex, callback) => {\n        let pos = 0;\n        let i = -1;\n        let match;\n\n        while ((match = XRegExp.exec(str, regex, pos))) {\n            // Because `regex` is provided to `callback`, the function could use the deprecated/\n            // nonstandard `RegExp.prototype.compile` to mutate the regex. However, since `XRegExp.exec`\n            // doesn't use `lastIndex` to set the search position, this can't lead to an infinite loop,\n            // at least. Actually, because of the way `XRegExp.exec` caches globalized versions of\n            // regexes, mutating the regex will not have any effect on the iteration or matched strings,\n            // which is a nice side effect that brings extra safety.\n            callback(match, ++i, str, regex);\n\n            pos = match.index + (match[0].length || 1);\n        }\n    };\n\n    /**\n     * Copies a regex object and adds flag `g`. The copy maintains extended data, is augmented with\n     * `XRegExp.prototype` properties, and has a fresh `lastIndex` property (set to zero). Native\n     * regexes are not recompiled using XRegExp syntax.\n     *\n     * @memberOf XRegExp\n     * @param {RegExp} regex Regex to globalize.\n     * @returns {RegExp} Copy of the provided regex with flag `g` added.\n     * @example\n     *\n     * const globalCopy = XRegExp.globalize(/regex/);\n     * globalCopy.global; // -> true\n     */\n    XRegExp.globalize = (regex) => copyRegex(regex, {addG: true});\n\n    /**\n     * Installs optional features according to the specified options. Can be undone using\n     * `XRegExp.uninstall`.\n     *\n     * @memberOf XRegExp\n     * @param {Object|String} options Options object or string.\n     * @example\n     *\n     * // With an options object\n     * XRegExp.install({\n     *   // Enables support for astral code points in Unicode addons (implicitly sets flag A)\n     *   astral: true,\n     *\n     *   // Adds named capture groups to the `groups` property of matches\n     *   namespacing: true\n     * });\n     *\n     * // With an options string\n     * XRegExp.install('astral namespacing');\n     */\n    XRegExp.install = (options) => {\n        options = prepareOptions(options);\n\n        if (!features.astral && options.astral) {\n            setAstral(true);\n        }\n\n        if (!features.namespacing && options.namespacing) {\n            setNamespacing(true);\n        }\n    };\n\n    /**\n     * Checks whether an individual optional feature is installed.\n     *\n     * @memberOf XRegExp\n     * @param {String} feature Name of the feature to check. One of:\n     *   - `astral`\n     *   - `namespacing`\n     * @returns {Boolean} Whether the feature is installed.\n     * @example\n     *\n     * XRegExp.isInstalled('astral');\n     */\n    XRegExp.isInstalled = (feature) => !!(features[feature]);\n\n    /**\n     * Returns `true` if an object is a regex; `false` if it isn't. This works correctly for regexes\n     * created in another frame, when `instanceof` and `constructor` checks would fail.\n     *\n     * @memberOf XRegExp\n     * @param {*} value Object to check.\n     * @returns {Boolean} Whether the object is a `RegExp` object.\n     * @example\n     *\n     * XRegExp.isRegExp('string'); // -> false\n     * XRegExp.isRegExp(/regex/i); // -> true\n     * XRegExp.isRegExp(RegExp('^', 'm')); // -> true\n     * XRegExp.isRegExp(XRegExp('(?s).')); // -> true\n     */\n    XRegExp.isRegExp = (value) => toString.call(value) === '[object RegExp]'; // isType(value, 'RegExp');\n\n    /**\n     * Returns the first matched string, or in global mode, an array containing all matched strings.\n     * This is essentially a more convenient re-implementation of `String.prototype.match` that gives\n     * the result types you actually want (string instead of `exec`-style array in match-first mode,\n     * and an empty array instead of `null` when no matches are found in match-all mode). It also lets\n     * you override flag g and ignore `lastIndex`, and fixes browser bugs.\n     *\n     * @memberOf XRegExp\n     * @param {String} str String to search.\n     * @param {RegExp} regex Regex to search with.\n     * @param {String} [scope='one'] Use 'one' to return the first match as a string. Use 'all' to\n     *   return an array of all matched strings. If not explicitly specified and `regex` uses flag g,\n     *   `scope` is 'all'.\n     * @returns {String|Array} In match-first mode: First match as a string, or `null`. In match-all\n     *   mode: Array of all matched strings, or an empty array.\n     * @example\n     *\n     * // Match first\n     * XRegExp.match('abc', /\\w/); // -> 'a'\n     * XRegExp.match('abc', /\\w/g, 'one'); // -> 'a'\n     * XRegExp.match('abc', /x/g, 'one'); // -> null\n     *\n     * // Match all\n     * XRegExp.match('abc', /\\w/g); // -> ['a', 'b', 'c']\n     * XRegExp.match('abc', /\\w/, 'all'); // -> ['a', 'b', 'c']\n     * XRegExp.match('abc', /x/, 'all'); // -> []\n     */\n    XRegExp.match = (str, regex, scope) => {\n        const global = (regex.global && scope !== 'one') || scope === 'all';\n        const cacheKey = ((global ? 'g' : '') + (regex.sticky ? 'y' : '')) || 'noGY';\n\n        regex[REGEX_DATA] = regex[REGEX_DATA] || {};\n\n        // Shares cached copies with `XRegExp.exec`/`replace`\n        const r2 = regex[REGEX_DATA][cacheKey] || (\n            regex[REGEX_DATA][cacheKey] = copyRegex(regex, {\n                addG: !!global,\n                removeG: scope === 'one',\n                isInternalOnly: true\n            })\n        );\n\n        const result = nativ.match.call(toObject(str), r2);\n\n        if (regex.global) {\n            regex.lastIndex = (\n                (scope === 'one' && result) ?\n                    // Can't use `r2.lastIndex` since `r2` is nonglobal in this case\n                    (result.index + result[0].length) : 0\n            );\n        }\n\n        return global ? (result || []) : (result && result[0]);\n    };\n\n    /**\n     * Retrieves the matches from searching a string using a chain of regexes that successively search\n     * within previous matches. The provided `chain` array can contain regexes and or objects with\n     * `regex` and `backref` properties. When a backreference is specified, the named or numbered\n     * backreference is passed forward to the next regex or returned.\n     *\n     * @memberOf XRegExp\n     * @param {String} str String to search.\n     * @param {Array} chain Regexes that each search for matches within preceding results.\n     * @returns {Array} Matches by the last regex in the chain, or an empty array.\n     * @example\n     *\n     * // Basic usage; matches numbers within <b> tags\n     * XRegExp.matchChain('1 <b>2</b> 3 <b>4 a 56</b>', [\n     *   XRegExp('(?is)<b>.*?</b>'),\n     *   /\\d+/\n     * ]);\n     * // -> ['2', '4', '56']\n     *\n     * // Passing forward and returning specific backreferences\n     * html = '<a href=\"http://xregexp.com/api/\">XRegExp</a>\\\n     *         <a href=\"http://www.google.com/\">Google</a>';\n     * XRegExp.matchChain(html, [\n     *   {regex: /<a href=\"([^\"]+)\">/i, backref: 1},\n     *   {regex: XRegExp('(?i)^https?://(?<domain>[^/?#]+)'), backref: 'domain'}\n     * ]);\n     * // -> ['xregexp.com', 'www.google.com']\n     */\n    XRegExp.matchChain = (str, chain) => (function recurseChain(values, level) {\n        const item = chain[level].regex ? chain[level] : {regex: chain[level]};\n        const matches = [];\n\n        function addMatch(match) {\n            if (item.backref) {\n                const ERR_UNDEFINED_GROUP = `Backreference to undefined group: ${item.backref}`;\n                const isNamedBackref = isNaN(item.backref);\n\n                if (isNamedBackref && XRegExp.isInstalled('namespacing')) {\n                    // `groups` has `null` as prototype, so using `in` instead of `hasOwnProperty`\n                    if (!(item.backref in match.groups)) {\n                        throw new ReferenceError(ERR_UNDEFINED_GROUP);\n                    }\n                } else if (!match.hasOwnProperty(item.backref)) {\n                    throw new ReferenceError(ERR_UNDEFINED_GROUP);\n                }\n\n                const backrefValue = isNamedBackref && XRegExp.isInstalled('namespacing') ?\n                    match.groups[item.backref] :\n                    match[item.backref];\n\n                matches.push(backrefValue || '');\n            } else {\n                matches.push(match[0]);\n            }\n        }\n\n        for (const value of values) {\n            XRegExp.forEach(value, item.regex, addMatch);\n        }\n\n        return ((level === chain.length - 1) || !matches.length) ?\n            matches :\n            recurseChain(matches, level + 1);\n    }([str], 0));\n\n    /**\n     * Returns a new string with one or all matches of a pattern replaced. The pattern can be a string\n     * or regex, and the replacement can be a string or a function to be called for each match. To\n     * perform a global search and replace, use the optional `scope` argument or include flag g if using\n     * a regex. Replacement strings can use `${n}` or `$<n>` for named and numbered backreferences.\n     * Replacement functions can use named backreferences via `arguments[0].name`. Also fixes browser\n     * bugs compared to the native `String.prototype.replace` and can be used reliably cross-browser.\n     *\n     * @memberOf XRegExp\n     * @param {String} str String to search.\n     * @param {RegExp|String} search Search pattern to be replaced.\n     * @param {String|Function} replacement Replacement string or a function invoked to create it.\n     *   Replacement strings can include special replacement syntax:\n     *     - $$ - Inserts a literal $ character.\n     *     - $&, $0 - Inserts the matched substring.\n     *     - $` - Inserts the string that precedes the matched substring (left context).\n     *     - $' - Inserts the string that follows the matched substring (right context).\n     *     - $n, $nn - Where n/nn are digits referencing an existent capturing group, inserts\n     *       backreference n/nn.\n     *     - ${n}, $<n> - Where n is a name or any number of digits that reference an existent capturing\n     *       group, inserts backreference n.\n     *   Replacement functions are invoked with three or more arguments:\n     *     - The matched substring (corresponds to $& above). Named backreferences are accessible as\n     *       properties of this first argument.\n     *     - 0..n arguments, one for each backreference (corresponding to $1, $2, etc. above).\n     *     - The zero-based index of the match within the total search string.\n     *     - The total string being searched.\n     * @param {String} [scope='one'] Use 'one' to replace the first match only, or 'all'. If not\n     *   explicitly specified and using a regex with flag g, `scope` is 'all'.\n     * @returns {String} New string with one or all matches replaced.\n     * @example\n     *\n     * // Regex search, using named backreferences in replacement string\n     * const name = XRegExp('(?<first>\\\\w+) (?<last>\\\\w+)');\n     * XRegExp.replace('John Smith', name, '$<last>, $<first>');\n     * // -> 'Smith, John'\n     *\n     * // Regex search, using named backreferences in replacement function\n     * XRegExp.replace('John Smith', name, (match) => `${match.last}, ${match.first}`);\n     * // -> 'Smith, John'\n     *\n     * // String search, with replace-all\n     * XRegExp.replace('RegExp builds RegExps', 'RegExp', 'XRegExp', 'all');\n     * // -> 'XRegExp builds XRegExps'\n     */\n    XRegExp.replace = (str, search, replacement, scope) => {\n        const isRegex = XRegExp.isRegExp(search);\n        const global = (search.global && scope !== 'one') || scope === 'all';\n        const cacheKey = ((global ? 'g' : '') + (search.sticky ? 'y' : '')) || 'noGY';\n        let s2 = search;\n\n        if (isRegex) {\n            search[REGEX_DATA] = search[REGEX_DATA] || {};\n\n            // Shares cached copies with `XRegExp.exec`/`match`. Since a copy is used, `search`'s\n            // `lastIndex` isn't updated *during* replacement iterations\n            s2 = search[REGEX_DATA][cacheKey] || (\n                search[REGEX_DATA][cacheKey] = copyRegex(search, {\n                    addG: !!global,\n                    removeG: scope === 'one',\n                    isInternalOnly: true\n                })\n            );\n        } else if (global) {\n            s2 = new RegExp(XRegExp.escape(String(search)), 'g');\n        }\n\n        // Fixed `replace` required for named backreferences, etc.\n        const result = fixed.replace.call(toObject(str), s2, replacement);\n\n        if (isRegex && search.global) {\n            // Fixes IE, Safari bug (last tested IE 9, Safari 5.1)\n            search.lastIndex = 0;\n        }\n\n        return result;\n    };\n\n    /**\n     * Performs batch processing of string replacements. Used like `XRegExp.replace`, but accepts an\n     * array of replacement details. Later replacements operate on the output of earlier replacements.\n     * Replacement details are accepted as an array with a regex or string to search for, the\n     * replacement string or function, and an optional scope of 'one' or 'all'. Uses the XRegExp\n     * replacement text syntax, which supports named backreference properties via `${name}` or\n     * `$<name>`.\n     *\n     * @memberOf XRegExp\n     * @param {String} str String to search.\n     * @param {Array} replacements Array of replacement detail arrays.\n     * @returns {String} New string with all replacements.\n     * @example\n     *\n     * str = XRegExp.replaceEach(str, [\n     *   [XRegExp('(?<name>a)'), 'z${name}'],\n     *   [/b/gi, 'y'],\n     *   [/c/g, 'x', 'one'], // scope 'one' overrides /g\n     *   [/d/, 'w', 'all'],  // scope 'all' overrides lack of /g\n     *   ['e', 'v', 'all'],  // scope 'all' allows replace-all for strings\n     *   [/f/g, ($0) => $0.toUpperCase()]\n     * ]);\n     */\n    XRegExp.replaceEach = (str, replacements) => {\n        for (const r of replacements) {\n            str = XRegExp.replace(str, r[0], r[1], r[2]);\n        }\n\n        return str;\n    };\n\n    /**\n     * Splits a string into an array of strings using a regex or string separator. Matches of the\n     * separator are not included in the result array. However, if `separator` is a regex that contains\n     * capturing groups, backreferences are spliced into the result each time `separator` is matched.\n     * Fixes browser bugs compared to the native `String.prototype.split` and can be used reliably\n     * cross-browser.\n     *\n     * @memberOf XRegExp\n     * @param {String} str String to split.\n     * @param {RegExp|String} separator Regex or string to use for separating the string.\n     * @param {Number} [limit] Maximum number of items to include in the result array.\n     * @returns {Array} Array of substrings.\n     * @example\n     *\n     * // Basic use\n     * XRegExp.split('a b c', ' ');\n     * // -> ['a', 'b', 'c']\n     *\n     * // With limit\n     * XRegExp.split('a b c', ' ', 2);\n     * // -> ['a', 'b']\n     *\n     * // Backreferences in result array\n     * XRegExp.split('..word1..', /([a-z]+)(\\d+)/i);\n     * // -> ['..', 'word', '1', '..']\n     */\n    XRegExp.split = (str, separator, limit) => fixed.split.call(toObject(str), separator, limit);\n\n    /**\n     * Executes a regex search in a specified string. Returns `true` or `false`. Optional `pos` and\n     * `sticky` arguments specify the search start position, and whether the match must start at the\n     * specified position only. The `lastIndex` property of the provided regex is not used, but is\n     * updated for compatibility. Also fixes browser bugs compared to the native\n     * `RegExp.prototype.test` and can be used reliably cross-browser.\n     *\n     * @memberOf XRegExp\n     * @param {String} str String to search.\n     * @param {RegExp} regex Regex to search with.\n     * @param {Number} [pos=0] Zero-based index at which to start the search.\n     * @param {Boolean|String} [sticky=false] Whether the match must start at the specified position\n     *   only. The string `'sticky'` is accepted as an alternative to `true`.\n     * @returns {Boolean} Whether the regex matched the provided value.\n     * @example\n     *\n     * // Basic use\n     * XRegExp.test('abc', /c/); // -> true\n     *\n     * // With pos and sticky\n     * XRegExp.test('abc', /c/, 0, 'sticky'); // -> false\n     * XRegExp.test('abc', /c/, 2, 'sticky'); // -> true\n     */\n    // Do this the easy way :-)\n    XRegExp.test = (str, regex, pos, sticky) => !!XRegExp.exec(str, regex, pos, sticky);\n\n    /**\n     * Uninstalls optional features according to the specified options. All optional features start out\n     * uninstalled, so this is used to undo the actions of `XRegExp.install`.\n     *\n     * @memberOf XRegExp\n     * @param {Object|String} options Options object or string.\n     * @example\n     *\n     * // With an options object\n     * XRegExp.uninstall({\n     *   // Disables support for astral code points in Unicode addons\n     *   astral: true,\n     *\n     *   // Don't add named capture groups to the `groups` property of matches\n     *   namespacing: true\n     * });\n     *\n     * // With an options string\n     * XRegExp.uninstall('astral namespacing');\n     */\n    XRegExp.uninstall = (options) => {\n        options = prepareOptions(options);\n\n        if (features.astral && options.astral) {\n            setAstral(false);\n        }\n\n        if (features.namespacing && options.namespacing) {\n            setNamespacing(false);\n        }\n    };\n\n    /**\n     * Returns an XRegExp object that is the union of the given patterns. Patterns can be provided as\n     * regex objects or strings. Metacharacters are escaped in patterns provided as strings.\n     * Backreferences in provided regex objects are automatically renumbered to work correctly within\n     * the larger combined pattern. Native flags used by provided regexes are ignored in favor of the\n     * `flags` argument.\n     *\n     * @memberOf XRegExp\n     * @param {Array} patterns Regexes and strings to combine.\n     * @param {String} [flags] Any combination of XRegExp flags.\n     * @param {Object} [options] Options object with optional properties:\n     *   - `conjunction` {String} Type of conjunction to use: 'or' (default) or 'none'.\n     * @returns {RegExp} Union of the provided regexes and strings.\n     * @example\n     *\n     * XRegExp.union(['a+b*c', /(dogs)\\1/, /(cats)\\1/], 'i');\n     * // -> /a\\+b\\*c|(dogs)\\1|(cats)\\2/i\n     *\n     * XRegExp.union([/man/, /bear/, /pig/], 'i', {conjunction: 'none'});\n     * // -> /manbearpig/i\n     */\n    XRegExp.union = (patterns, flags, options) => {\n        options = options || {};\n        const conjunction = options.conjunction || 'or';\n        let numCaptures = 0;\n        let numPriorCaptures;\n        let captureNames;\n\n        function rewrite(match, paren, backref) {\n            const name = captureNames[numCaptures - numPriorCaptures];\n\n            // Capturing group\n            if (paren) {\n                ++numCaptures;\n                // If the current capture has a name, preserve the name\n                if (name) {\n                    return `(?<${name}>`;\n                }\n            // Backreference\n            } else if (backref) {\n                // Rewrite the backreference\n                return `\\\\${+backref + numPriorCaptures}`;\n            }\n\n            return match;\n        }\n\n        if (!(isType(patterns, 'Array') && patterns.length)) {\n            throw new TypeError('Must provide a nonempty array of patterns to merge');\n        }\n\n        const parts = /(\\()(?!\\?)|\\\\([1-9]\\d*)|\\\\[\\s\\S]|\\[(?:[^\\\\\\]]|\\\\[\\s\\S])*\\]/g;\n        const output = [];\n        for (const pattern of patterns) {\n            if (XRegExp.isRegExp(pattern)) {\n                numPriorCaptures = numCaptures;\n                captureNames = (pattern[REGEX_DATA] && pattern[REGEX_DATA].captureNames) || [];\n\n                // Rewrite backreferences. Passing to XRegExp dies on octals and ensures patterns are\n                // independently valid; helps keep this simple. Named captures are put back\n                output.push(nativ.replace.call(XRegExp(pattern.source).source, parts, rewrite));\n            } else {\n                output.push(XRegExp.escape(pattern));\n            }\n        }\n\n        const separator = conjunction === 'none' ? '' : '|';\n        return XRegExp(output.join(separator), flags);\n    };\n\n    // ==--------------------------==\n    // Fixed/extended native methods\n    // ==--------------------------==\n\n    /**\n     * Adds named capture support (with backreferences returned as `result.name`), and fixes browser\n     * bugs in the native `RegExp.prototype.exec`. Use via `XRegExp.exec`.\n     *\n     * @memberOf RegExp\n     * @param {String} str String to search.\n     * @returns {Array} Match array with named backreference properties, or `null`.\n     */\n    fixed.exec = function(str) {\n        const origLastIndex = this.lastIndex;\n        const match = nativ.exec.apply(this, arguments);\n\n        if (match) {\n            // Fix browsers whose `exec` methods don't return `undefined` for nonparticipating capturing\n            // groups. This fixes IE 5.5-8, but not IE 9's quirks mode or emulation of older IEs. IE 9\n            // in standards mode follows the spec.\n            if (!correctExecNpcg && match.length > 1 && match.includes('')) {\n                const r2 = copyRegex(this, {\n                    removeG: true,\n                    isInternalOnly: true\n                });\n                // Using `str.slice(match.index)` rather than `match[0]` in case lookahead allowed\n                // matching due to characters outside the match\n                nativ.replace.call(String(str).slice(match.index), r2, (...args) => {\n                    const len = args.length;\n                    // Skip index 0 and the last 2\n                    for (let i = 1; i < len - 2; ++i) {\n                        if (args[i] === undefined) {\n                            match[i] = undefined;\n                        }\n                    }\n                });\n            }\n\n            // Attach named capture properties\n            let groupsObject = match;\n            if (XRegExp.isInstalled('namespacing')) {\n                // https://tc39.github.io/proposal-regexp-named-groups/#sec-regexpbuiltinexec\n                match.groups = Object.create(null);\n                groupsObject = match.groups;\n            }\n            if (this[REGEX_DATA] && this[REGEX_DATA].captureNames) {\n                // Skip index 0\n                for (let i = 1; i < match.length; ++i) {\n                    const name = this[REGEX_DATA].captureNames[i - 1];\n                    if (name) {\n                        groupsObject[name] = match[i];\n                    }\n                }\n            }\n\n            // Fix browsers that increment `lastIndex` after zero-length matches\n            if (this.global && !match[0].length && (this.lastIndex > match.index)) {\n                this.lastIndex = match.index;\n            }\n        }\n\n        if (!this.global) {\n            // Fixes IE, Opera bug (last tested IE 9, Opera 11.6)\n            this.lastIndex = origLastIndex;\n        }\n\n        return match;\n    };\n\n    /**\n     * Fixes browser bugs in the native `RegExp.prototype.test`.\n     *\n     * @memberOf RegExp\n     * @param {String} str String to search.\n     * @returns {Boolean} Whether the regex matched the provided value.\n     */\n    fixed.test = function(str) {\n        // Do this the easy way :-)\n        return !!fixed.exec.call(this, str);\n    };\n\n    /**\n     * Adds named capture support (with backreferences returned as `result.name`), and fixes browser\n     * bugs in the native `String.prototype.match`.\n     *\n     * @memberOf String\n     * @param {RegExp|*} regex Regex to search with. If not a regex object, it is passed to `RegExp`.\n     * @returns {Array} If `regex` uses flag g, an array of match strings or `null`. Without flag g,\n     *   the result of calling `regex.exec(this)`.\n     */\n    fixed.match = function(regex) {\n        if (!XRegExp.isRegExp(regex)) {\n            // Use the native `RegExp` rather than `XRegExp`\n            regex = new RegExp(regex);\n        } else if (regex.global) {\n            const result = nativ.match.apply(this, arguments);\n            // Fixes IE bug\n            regex.lastIndex = 0;\n\n            return result;\n        }\n\n        return fixed.exec.call(regex, toObject(this));\n    };\n\n    /**\n     * Adds support for `${n}` (or `$<n>`) tokens for named and numbered backreferences in replacement\n     * text, and provides named backreferences to replacement functions as `arguments[0].name`. Also\n     * fixes browser bugs in replacement text syntax when performing a replacement using a nonregex\n     * search value, and the value of a replacement regex's `lastIndex` property during replacement\n     * iterations and upon completion. Note that this doesn't support SpiderMonkey's proprietary third\n     * (`flags`) argument. Use via `XRegExp.replace`.\n     *\n     * @memberOf String\n     * @param {RegExp|String} search Search pattern to be replaced.\n     * @param {String|Function} replacement Replacement string or a function invoked to create it.\n     * @returns {String} New string with one or all matches replaced.\n     */\n    fixed.replace = function(search, replacement) {\n        const isRegex = XRegExp.isRegExp(search);\n        let origLastIndex;\n        let captureNames;\n        let result;\n\n        if (isRegex) {\n            if (search[REGEX_DATA]) {\n                ({captureNames} = search[REGEX_DATA]);\n            }\n            // Only needed if `search` is nonglobal\n            origLastIndex = search.lastIndex;\n        } else {\n            search += ''; // Type-convert\n        }\n\n        // Don't use `typeof`; some older browsers return 'function' for regex objects\n        if (isType(replacement, 'Function')) {\n            // Stringifying `this` fixes a bug in IE < 9 where the last argument in replacement\n            // functions isn't type-converted to a string\n            result = nativ.replace.call(String(this), search, (...args) => {\n                if (captureNames) {\n                    let groupsObject;\n\n                    if (XRegExp.isInstalled('namespacing')) {\n                        // https://tc39.github.io/proposal-regexp-named-groups/#sec-regexpbuiltinexec\n                        groupsObject = Object.create(null);\n                        args.push(groupsObject);\n                    } else {\n                        // Change the `args[0]` string primitive to a `String` object that can store\n                        // properties. This really does need to use `String` as a constructor\n                        args[0] = new String(args[0]);\n                        [groupsObject] = args;\n                    }\n\n                    // Store named backreferences\n                    for (let i = 0; i < captureNames.length; ++i) {\n                        if (captureNames[i]) {\n                            groupsObject[captureNames[i]] = args[i + 1];\n                        }\n                    }\n                }\n                // Update `lastIndex` before calling `replacement`. Fixes IE, Chrome, Firefox, Safari\n                // bug (last tested IE 9, Chrome 17, Firefox 11, Safari 5.1)\n                if (isRegex && search.global) {\n                    search.lastIndex = args[args.length - 2] + args[0].length;\n                }\n                // ES6 specs the context for replacement functions as `undefined`\n                return replacement(...args);\n            });\n        } else {\n            // Ensure that the last value of `args` will be a string when given nonstring `this`,\n            // while still throwing on null or undefined context\n            result = nativ.replace.call(this == null ? this : String(this), search, (...args) => {\n                return nativ.replace.call(String(replacement), replacementToken, replacer);\n\n                function replacer($0, bracketed, angled, dollarToken) {\n                    bracketed = bracketed || angled;\n                    // Named or numbered backreference with curly or angled braces\n                    if (bracketed) {\n                        // XRegExp behavior for `${n}` or `$<n>`:\n                        // 1. Backreference to numbered capture, if `n` is an integer. Use `0` for the\n                        //    entire match. Any number of leading zeros may be used.\n                        // 2. Backreference to named capture `n`, if it exists and is not an integer\n                        //    overridden by numbered capture. In practice, this does not overlap with\n                        //    numbered capture since XRegExp does not allow named capture to use a bare\n                        //    integer as the name.\n                        // 3. If the name or number does not refer to an existing capturing group, it's\n                        //    an error.\n                        let n = +bracketed; // Type-convert; drop leading zeros\n                        if (n <= args.length - 3) {\n                            return args[n] || '';\n                        }\n                        // Groups with the same name is an error, else would need `lastIndexOf`\n                        n = captureNames ? captureNames.indexOf(bracketed) : -1;\n                        if (n < 0) {\n                            throw new SyntaxError(`Backreference to undefined group ${$0}`);\n                        }\n                        return args[n + 1] || '';\n                    }\n                    // Else, special variable or numbered backreference without curly braces\n                    if (dollarToken === '$') { // $$\n                        return '$';\n                    }\n                    if (dollarToken === '&' || +dollarToken === 0) { // $&, $0 (not followed by 1-9), $00\n                        return args[0];\n                    }\n                    if (dollarToken === '`') { // $` (left context)\n                        return args[args.length - 1].slice(0, args[args.length - 2]);\n                    }\n                    if (dollarToken === \"'\") { // $' (right context)\n                        return args[args.length - 1].slice(args[args.length - 2] + args[0].length);\n                    }\n                    // Else, numbered backreference without braces\n                    dollarToken = +dollarToken; // Type-convert; drop leading zero\n                    // XRegExp behavior for `$n` and `$nn`:\n                    // - Backrefs end after 1 or 2 digits. Use `${..}` or `$<..>` for more digits.\n                    // - `$1` is an error if no capturing groups.\n                    // - `$10` is an error if less than 10 capturing groups. Use `${1}0` or `$<1>0`\n                    //   instead.\n                    // - `$01` is `$1` if at least one capturing group, else it's an error.\n                    // - `$0` (not followed by 1-9) and `$00` are the entire match.\n                    // Native behavior, for comparison:\n                    // - Backrefs end after 1 or 2 digits. Cannot reference capturing group 100+.\n                    // - `$1` is a literal `$1` if no capturing groups.\n                    // - `$10` is `$1` followed by a literal `0` if less than 10 capturing groups.\n                    // - `$01` is `$1` if at least one capturing group, else it's a literal `$01`.\n                    // - `$0` is a literal `$0`.\n                    if (!isNaN(dollarToken)) {\n                        if (dollarToken > args.length - 3) {\n                            throw new SyntaxError(`Backreference to undefined group ${$0}`);\n                        }\n                        return args[dollarToken] || '';\n                    }\n                    // `$` followed by an unsupported char is an error, unlike native JS\n                    throw new SyntaxError(`Invalid token ${$0}`);\n                }\n            });\n        }\n\n        if (isRegex) {\n            if (search.global) {\n                // Fixes IE, Safari bug (last tested IE 9, Safari 5.1)\n                search.lastIndex = 0;\n            } else {\n                // Fixes IE, Opera bug (last tested IE 9, Opera 11.6)\n                search.lastIndex = origLastIndex;\n            }\n        }\n\n        return result;\n    };\n\n    /**\n     * Fixes browser bugs in the native `String.prototype.split`. Use via `XRegExp.split`.\n     *\n     * @memberOf String\n     * @param {RegExp|String} separator Regex or string to use for separating the string.\n     * @param {Number} [limit] Maximum number of items to include in the result array.\n     * @returns {Array} Array of substrings.\n     */\n    fixed.split = function(separator, limit) {\n        if (!XRegExp.isRegExp(separator)) {\n            // Browsers handle nonregex split correctly, so use the faster native method\n            return nativ.split.apply(this, arguments);\n        }\n\n        const str = String(this);\n        const output = [];\n        const origLastIndex = separator.lastIndex;\n        let lastLastIndex = 0;\n        let lastLength;\n\n        // Values for `limit`, per the spec:\n        // If undefined: pow(2,32) - 1\n        // If 0, Infinity, or NaN: 0\n        // If positive number: limit = floor(limit); if (limit >= pow(2,32)) limit -= pow(2,32);\n        // If negative number: pow(2,32) - floor(abs(limit))\n        // If other: Type-convert, then use the above rules\n        // This line fails in very strange ways for some values of `limit` in Opera 10.5-10.63, unless\n        // Opera Dragonfly is open (go figure). It works in at least Opera 9.5-10.1 and 11+\n        limit = (limit === undefined ? -1 : limit) >>> 0;\n\n        XRegExp.forEach(str, separator, (match) => {\n            // This condition is not the same as `if (match[0].length)`\n            if ((match.index + match[0].length) > lastLastIndex) {\n                output.push(str.slice(lastLastIndex, match.index));\n                if (match.length > 1 && match.index < str.length) {\n                    Array.prototype.push.apply(output, match.slice(1));\n                }\n                lastLength = match[0].length;\n                lastLastIndex = match.index + lastLength;\n            }\n        });\n\n        if (lastLastIndex === str.length) {\n            if (!nativ.test.call(separator, '') || lastLength) {\n                output.push('');\n            }\n        } else {\n            output.push(str.slice(lastLastIndex));\n        }\n\n        separator.lastIndex = origLastIndex;\n        return output.length > limit ? output.slice(0, limit) : output;\n    };\n\n    // ==--------------------------==\n    // Built-in syntax/flag tokens\n    // ==--------------------------==\n\n    /*\n     * Letter escapes that natively match literal characters: `\\a`, `\\A`, etc. These should be\n     * SyntaxErrors but are allowed in web reality. XRegExp makes them errors for cross-browser\n     * consistency and to reserve their syntax, but lets them be superseded by addons.\n     */\n    XRegExp.addToken(\n        /\\\\([ABCE-RTUVXYZaeg-mopqyz]|c(?![A-Za-z])|u(?![\\dA-Fa-f]{4}|{[\\dA-Fa-f]+})|x(?![\\dA-Fa-f]{2}))/,\n        (match, scope) => {\n            // \\B is allowed in default scope only\n            if (match[1] === 'B' && scope === defaultScope) {\n                return match[0];\n            }\n            throw new SyntaxError(`Invalid escape ${match[0]}`);\n        },\n        {\n            scope: 'all',\n            leadChar: '\\\\'\n        }\n    );\n\n    /*\n     * Unicode code point escape with curly braces: `\\u{N..}`. `N..` is any one or more digit\n     * hexadecimal number from 0-10FFFF, and can include leading zeros. Requires the native ES6 `u` flag\n     * to support code points greater than U+FFFF. Avoids converting code points above U+FFFF to\n     * surrogate pairs (which could be done without flag `u`), since that could lead to broken behavior\n     * if you follow a `\\u{N..}` token that references a code point above U+FFFF with a quantifier, or\n     * if you use the same in a character class.\n     */\n    XRegExp.addToken(\n        /\\\\u{([\\dA-Fa-f]+)}/,\n        (match, scope, flags) => {\n            const code = dec(match[1]);\n            if (code > 0x10FFFF) {\n                throw new SyntaxError(`Invalid Unicode code point ${match[0]}`);\n            }\n            if (code <= 0xFFFF) {\n                // Converting to \\uNNNN avoids needing to escape the literal character and keep it\n                // separate from preceding tokens\n                return `\\\\u${pad4(hex(code))}`;\n            }\n            // If `code` is between 0xFFFF and 0x10FFFF, require and defer to native handling\n            if (hasNativeU && flags.includes('u')) {\n                return match[0];\n            }\n            throw new SyntaxError('Cannot use Unicode code point above \\\\u{FFFF} without flag u');\n        },\n        {\n            scope: 'all',\n            leadChar: '\\\\'\n        }\n    );\n\n    /*\n     * Empty character class: `[]` or `[^]`. This fixes a critical cross-browser syntax inconsistency.\n     * Unless this is standardized (per the ES spec), regex syntax can't be accurately parsed because\n     * character class endings can't be determined.\n     */\n    XRegExp.addToken(\n        /\\[(\\^?)\\]/,\n        // For cross-browser compatibility with ES3, convert [] to \\b\\B and [^] to [\\s\\S].\n        // (?!) should work like \\b\\B, but is unreliable in some versions of Firefox\n        /* eslint-disable no-confusing-arrow */\n        (match) => (match[1] ? '[\\\\s\\\\S]' : '\\\\b\\\\B'),\n        /* eslint-enable no-confusing-arrow */\n        {leadChar: '['}\n    );\n\n    /*\n     * Comment pattern: `(?# )`. Inline comments are an alternative to the line comments allowed in\n     * free-spacing mode (flag x).\n     */\n    XRegExp.addToken(\n        /\\(\\?#[^)]*\\)/,\n        getContextualTokenSeparator,\n        {leadChar: '('}\n    );\n\n    /*\n     * Whitespace and line comments, in free-spacing mode (aka extended mode, flag x) only.\n     */\n    XRegExp.addToken(\n        /\\s+|#[^\\n]*\\n?/,\n        getContextualTokenSeparator,\n        {flag: 'x'}\n    );\n\n    /*\n     * Dot, in dotall mode (aka singleline mode, flag s) only.\n     */\n    XRegExp.addToken(\n        /\\./,\n        () => '[\\\\s\\\\S]',\n        {\n            flag: 's',\n            leadChar: '.'\n        }\n    );\n\n    /*\n     * Named backreference: `\\k<name>`. Backreference names can use the characters A-Z, a-z, 0-9, _,\n     * and $ only. Also allows numbered backreferences as `\\k<n>`.\n     */\n    XRegExp.addToken(\n        /\\\\k<([\\w$]+)>/,\n        function(match) {\n            // Groups with the same name is an error, else would need `lastIndexOf`\n            const index = isNaN(match[1]) ? (this.captureNames.indexOf(match[1]) + 1) : +match[1];\n            const endIndex = match.index + match[0].length;\n            if (!index || index > this.captureNames.length) {\n                throw new SyntaxError(`Backreference to undefined group ${match[0]}`);\n            }\n            // Keep backreferences separate from subsequent literal numbers. This avoids e.g.\n            // inadvertedly changing `(?<n>)\\k<n>1` to `()\\11`.\n            return `\\\\${index}${\n                endIndex === match.input.length || isNaN(match.input[endIndex]) ?\n                    '' : '(?:)'\n            }`;\n        },\n        {leadChar: '\\\\'}\n    );\n\n    /*\n     * Numbered backreference or octal, plus any following digits: `\\0`, `\\11`, etc. Octals except `\\0`\n     * not followed by 0-9 and backreferences to unopened capture groups throw an error. Other matches\n     * are returned unaltered. IE < 9 doesn't support backreferences above `\\99` in regex syntax.\n     */\n    XRegExp.addToken(\n        /\\\\(\\d+)/,\n        function(match, scope) {\n            if (\n                !(\n                    scope === defaultScope &&\n                    /^[1-9]/.test(match[1]) &&\n                    +match[1] <= this.captureNames.length\n                ) &&\n                match[1] !== '0'\n            ) {\n                throw new SyntaxError(`Cannot use octal escape or backreference to undefined group ${match[0]}`);\n            }\n            return match[0];\n        },\n        {\n            scope: 'all',\n            leadChar: '\\\\'\n        }\n    );\n\n    /*\n     * Named capturing group; match the opening delimiter only: `(?<name>`. Capture names can use the\n     * characters A-Z, a-z, 0-9, _, and $ only. Names can't be integers. Supports Python-style\n     * `(?P<name>` as an alternate syntax to avoid issues in some older versions of Opera which natively\n     * supported the Python-style syntax. Otherwise, XRegExp might treat numbered backreferences to\n     * Python-style named capture as octals.\n     */\n    XRegExp.addToken(\n        /\\(\\?P?<([\\w$]+)>/,\n        function(match) {\n            // Disallow bare integers as names because named backreferences are added to match arrays\n            // and therefore numeric properties may lead to incorrect lookups\n            if (!isNaN(match[1])) {\n                throw new SyntaxError(`Cannot use integer as capture name ${match[0]}`);\n            }\n            if (!XRegExp.isInstalled('namespacing') && (match[1] === 'length' || match[1] === '__proto__')) {\n                throw new SyntaxError(`Cannot use reserved word as capture name ${match[0]}`);\n            }\n            if (this.captureNames.includes(match[1])) {\n                throw new SyntaxError(`Cannot use same name for multiple groups ${match[0]}`);\n            }\n            this.captureNames.push(match[1]);\n            this.hasNamedCapture = true;\n            return '(';\n        },\n        {leadChar: '('}\n    );\n\n    /*\n     * Capturing group; match the opening parenthesis only. Required for support of named capturing\n     * groups. Also adds explicit capture mode (flag n).\n     */\n    XRegExp.addToken(\n        /\\((?!\\?)/,\n        function(match, scope, flags) {\n            if (flags.includes('n')) {\n                return '(?:';\n            }\n            this.captureNames.push(null);\n            return '(';\n        },\n        {\n            optionalFlags: 'n',\n            leadChar: '('\n        }\n    );\n\n    return XRegExp;\n\n});\n"]}