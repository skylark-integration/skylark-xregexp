{"version":3,"sources":["addons/matchrecursive.js"],"names":["define","XRegExp","row","name","value","start","end","matchRecursive","str","left","right","flags","options","global","includes","sticky","basicFlags","replace","escapeChar","vN","valueNames","output","outerStart","innerStart","leftMatch","rightMatch","esc","openTokens","delimStart","delimEnd","lastOuterEnd","length","Error","escape","RegExp","union","conjunction","source","exec","index","push","slice"],"mappings":";;;;;;;AAKAA,UAAU,WACN,OAAQC,IAOJ,SAASC,EAAIC,EAAMC,EAAOC,EAAOC,GAC7B,OACIH,KAAAA,EACAC,MAAAA,EACAC,MAAAA,EACAC,IAAAA,GAsDRL,EAAQM,eAAiB,EAACC,EAAKC,EAAMC,EAAOC,EAAOC,KAC/CD,EAAQA,GAAS,GACjBC,EAAUA,MACV,MAAMC,EAASF,EAAMG,SAAS,KACxBC,EAASJ,EAAMG,SAAS,KAExBE,EAAaL,EAAMM,QAAQ,KAAM,IACvC,IAAIC,WAACA,GAAcN,EACnB,MAAMO,EAAKP,EAAQQ,WACbC,KACN,IAIIC,EACAC,EACAC,EACAC,EACAC,EARAC,EAAa,EACbC,EAAa,EACbC,EAAW,EACXC,EAAe,EASnB,GAHArB,EAAOR,EAAQQ,EAAMO,GACrBN,EAAQT,EAAQS,EAAOM,GAEnBE,EAAY,CACZ,GAAIA,EAAWa,OAAS,EACpB,MAAM,IAAIC,MAAM,6CAEpBd,EAAajB,EAAQgC,OAAOf,GAM5BQ,EAAM,IAAIQ,aACAhB,mBAKFjB,EAAQkC,OAAO1B,EAAMC,GAAQ,IAAK0B,YAAa,OAAOC,YACpDnB,SAENP,EAAMM,QAAQ,WAAY,KAIlC,OAAa,CA0BT,GAvBIC,IACAW,IAAa5B,EAAQqC,KAAK9B,EAAKkB,EAAKG,EAAU,YAAc,KAAK,GAAGE,QAExEP,EAAYvB,EAAQqC,KAAK9B,EAAKC,EAAMoB,GACpCJ,EAAaxB,EAAQqC,KAAK9B,EAAKE,EAAOmB,GAElCL,GAAaC,IACTD,EAAUe,OAASd,EAAWc,MAC9Bd,EAAa,KAEbD,EAAY,MAahBA,GAAaC,EAEbI,GADAD,GAAcJ,GAAaC,GAAYc,QACdf,GAAaC,GAAY,GAAGM,YAClD,IAAKJ,EACR,MAEJ,GAAIZ,IAAWY,GAAcC,EAAaE,EACtC,MAEJ,GAAIN,EACKG,IACDL,EAAaM,EACbL,EAAaM,KAEfF,MACC,CAAA,IAAIF,IAAcE,EAwBrB,MAAM,IAAIK,MAAM,wCAvBhB,MAAOL,IACCR,GACIA,EAAG,IAAMG,EAAaQ,GACtBT,EAAOmB,KAAKtC,EAAIiB,EAAG,GAAIX,EAAIiC,MAAMX,EAAcR,GAAaQ,EAAcR,IAE1EH,EAAG,IACHE,EAAOmB,KAAKtC,EAAIiB,EAAG,GAAIX,EAAIiC,MAAMnB,EAAYC,GAAaD,EAAYC,IAEtEJ,EAAG,IACHE,EAAOmB,KAAKtC,EAAIiB,EAAG,GAAIX,EAAIiC,MAAMlB,EAAYK,GAAaL,EAAYK,IAEtET,EAAG,IACHE,EAAOmB,KAAKtC,EAAIiB,EAAG,GAAIX,EAAIiC,MAAMb,EAAYC,GAAWD,EAAYC,KAGxER,EAAOmB,KAAKhC,EAAIiC,MAAMlB,EAAYK,IAEtCE,EAAeD,GACVhB,GACD,MAORe,IAAeC,KACbA,EAQV,OAJIhB,IAAWE,GAAUI,GAAMA,EAAG,IAAMX,EAAIuB,OAASD,GACjDT,EAAOmB,KAAKtC,EAAIiB,EAAG,GAAIX,EAAIiC,MAAMX,GAAeA,EAActB,EAAIuB,SAG/DV","file":"../../addons/matchrecursive.js","sourcesContent":["/*!\n * XRegExp.matchRecursive 4.2.4\n * <xregexp.com>\n * Steven Levithan (c) 2009-present MIT License\n */\ndefine([],function(){\n    return (XRegExp) => {\n\n        /**\n         * Returns a match detail object composed of the provided values.\n         *\n         * @private\n         */\n        function row(name, value, start, end) {\n            return {\n                name,\n                value,\n                start,\n                end\n            };\n        }\n\n        /**\n         * Returns an array of match strings between outermost left and right delimiters, or an array of\n         * objects with detailed match parts and position data. An error is thrown if delimiters are\n         * unbalanced within the data.\n         *\n         * @memberOf XRegExp\n         * @param {String} str String to search.\n         * @param {String} left Left delimiter as an XRegExp pattern.\n         * @param {String} right Right delimiter as an XRegExp pattern.\n         * @param {String} [flags] Any native or XRegExp flags, used for the left and right delimiters.\n         * @param {Object} [options] Lets you specify `valueNames` and `escapeChar` options.\n         * @returns {Array} Array of matches, or an empty array.\n         * @example\n         *\n         * // Basic usage\n         * let str = '(t((e))s)t()(ing)';\n         * XRegExp.matchRecursive(str, '\\\\(', '\\\\)', 'g');\n         * // -> ['t((e))s', '', 'ing']\n         *\n         * // Extended information mode with valueNames\n         * str = 'Here is <div> <div>an</div></div> example';\n         * XRegExp.matchRecursive(str, '<div\\\\s*>', '</div>', 'gi', {\n         *   valueNames: ['between', 'left', 'match', 'right']\n         * });\n         * // -> [\n         * // {name: 'between', value: 'Here is ',       start: 0,  end: 8},\n         * // {name: 'left',    value: '<div>',          start: 8,  end: 13},\n         * // {name: 'match',   value: ' <div>an</div>', start: 13, end: 27},\n         * // {name: 'right',   value: '</div>',         start: 27, end: 33},\n         * // {name: 'between', value: ' example',       start: 33, end: 41}\n         * // ]\n         *\n         * // Omitting unneeded parts with null valueNames, and using escapeChar\n         * str = '...{1}.\\\\{{function(x,y){return {y:x}}}';\n         * XRegExp.matchRecursive(str, '{', '}', 'g', {\n         *   valueNames: ['literal', null, 'value', null],\n         *   escapeChar: '\\\\'\n         * });\n         * // -> [\n         * // {name: 'literal', value: '...',  start: 0, end: 3},\n         * // {name: 'value',   value: '1',    start: 4, end: 5},\n         * // {name: 'literal', value: '.\\\\{', start: 6, end: 9},\n         * // {name: 'value',   value: 'function(x,y){return {y:x}}', start: 10, end: 37}\n         * // ]\n         *\n         * // Sticky mode via flag y\n         * str = '<1><<<2>>><3>4<5>';\n         * XRegExp.matchRecursive(str, '<', '>', 'gy');\n         * // -> ['1', '<<2>>', '3']\n         */\n        XRegExp.matchRecursive = (str, left, right, flags, options) => {\n            flags = flags || '';\n            options = options || {};\n            const global = flags.includes('g');\n            const sticky = flags.includes('y');\n            // Flag `y` is controlled internally\n            const basicFlags = flags.replace(/y/g, '');\n            let {escapeChar} = options;\n            const vN = options.valueNames;\n            const output = [];\n            let openTokens = 0;\n            let delimStart = 0;\n            let delimEnd = 0;\n            let lastOuterEnd = 0;\n            let outerStart;\n            let innerStart;\n            let leftMatch;\n            let rightMatch;\n            let esc;\n            left = XRegExp(left, basicFlags);\n            right = XRegExp(right, basicFlags);\n\n            if (escapeChar) {\n                if (escapeChar.length > 1) {\n                    throw new Error('Cannot use more than one escape character');\n                }\n                escapeChar = XRegExp.escape(escapeChar);\n                // Example of concatenated `esc` regex:\n                // `escapeChar`: '%'\n                // `left`: '<'\n                // `right`: '>'\n                // Regex is: /(?:%[\\S\\s]|(?:(?!<|>)[^%])+)+/\n                esc = new RegExp(\n                    `(?:${escapeChar}[\\\\S\\\\s]|(?:(?!${\n                        // Using `XRegExp.union` safely rewrites backreferences in `left` and `right`.\n                        // Intentionally not passing `basicFlags` to `XRegExp.union` since any syntax\n                        // transformation resulting from those flags was already applied to `left` and\n                        // `right` when they were passed through the XRegExp constructor above.\n                        XRegExp.union([left, right], '', {conjunction: 'or'}).source\n                    })[^${escapeChar}])+)+`,\n                    // Flags `gy` not needed here\n                    flags.replace(/[^imu]+/g, '')\n                );\n            }\n\n            while (true) {\n                // If using an escape character, advance to the delimiter's next starting position,\n                // skipping any escaped characters in between\n                if (escapeChar) {\n                    delimEnd += (XRegExp.exec(str, esc, delimEnd, 'sticky') || [''])[0].length;\n                }\n                leftMatch = XRegExp.exec(str, left, delimEnd);\n                rightMatch = XRegExp.exec(str, right, delimEnd);\n                // Keep the leftmost match only\n                if (leftMatch && rightMatch) {\n                    if (leftMatch.index <= rightMatch.index) {\n                        rightMatch = null;\n                    } else {\n                        leftMatch = null;\n                    }\n                }\n                // Paths (LM: leftMatch, RM: rightMatch, OT: openTokens):\n                // LM | RM | OT | Result\n                // 1  | 0  | 1  | loop\n                // 1  | 0  | 0  | loop\n                // 0  | 1  | 1  | loop\n                // 0  | 1  | 0  | throw\n                // 0  | 0  | 1  | throw\n                // 0  | 0  | 0  | break\n                // The paths above don't include the sticky mode special case. The loop ends after the\n                // first completed match if not `global`.\n                if (leftMatch || rightMatch) {\n                    delimStart = (leftMatch || rightMatch).index;\n                    delimEnd = delimStart + (leftMatch || rightMatch)[0].length;\n                } else if (!openTokens) {\n                    break;\n                }\n                if (sticky && !openTokens && delimStart > lastOuterEnd) {\n                    break;\n                }\n                if (leftMatch) {\n                    if (!openTokens) {\n                        outerStart = delimStart;\n                        innerStart = delimEnd;\n                    }\n                    ++openTokens;\n                } else if (rightMatch && openTokens) {\n                    if (!--openTokens) {\n                        if (vN) {\n                            if (vN[0] && outerStart > lastOuterEnd) {\n                                output.push(row(vN[0], str.slice(lastOuterEnd, outerStart), lastOuterEnd, outerStart));\n                            }\n                            if (vN[1]) {\n                                output.push(row(vN[1], str.slice(outerStart, innerStart), outerStart, innerStart));\n                            }\n                            if (vN[2]) {\n                                output.push(row(vN[2], str.slice(innerStart, delimStart), innerStart, delimStart));\n                            }\n                            if (vN[3]) {\n                                output.push(row(vN[3], str.slice(delimStart, delimEnd), delimStart, delimEnd));\n                            }\n                        } else {\n                            output.push(str.slice(innerStart, delimStart));\n                        }\n                        lastOuterEnd = delimEnd;\n                        if (!global) {\n                            break;\n                        }\n                    }\n                } else {\n                    throw new Error('Unbalanced delimiter found in string');\n                }\n                // If the delimiter matched an empty string, avoid an infinite loop\n                if (delimStart === delimEnd) {\n                    ++delimEnd;\n                }\n            }\n\n            if (global && !sticky && vN && vN[0] && str.length > lastOuterEnd) {\n                output.push(row(vN[0], str.slice(lastOuterEnd), lastOuterEnd, str.length));\n            }\n\n            return output;\n        };\n    };\n});\n"]}