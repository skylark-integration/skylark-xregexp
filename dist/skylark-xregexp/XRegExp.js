/**
 * skylark-xregexp - A version of xregexp.js that ported to running on skylarkjs.
 * @author Hudaokeji, Inc.
 * @version v0.9.0
 * @link https://github.com/skylark-integration/skylark-xregexp/
 * @license MIT
 */
define([],function(){const e="xregexp",n={astral:!1,namespacing:!1},t={exec:RegExp.prototype.exec,test:RegExp.prototype.test,match:String.prototype.match,replace:String.prototype.replace,split:String.prototype.split},r={};let a={},l={};const s=[],o="default",i="class",c={default:/\\(?:0(?:[0-3][0-7]{0,2}|[4-7][0-7]?)?|[1-9]\d*|x[\dA-Fa-f]{2}|u(?:[\dA-Fa-f]{4}|{[\dA-Fa-f]+})|c[A-Za-z]|[\s\S])|\(\?(?:[:=!]|<[=!])|[?*+]\?|{\d+(?:,\d*)?}\??|[\s\S]/,class:/\\(?:[0-3][0-7]{0,2}|[4-7][0-7]?|x[\dA-Fa-f]{2}|u(?:[\dA-Fa-f]{4}|{[\dA-Fa-f]+})|c[A-Za-z]|[\s\S])|[\s\S]/},u=/\$(?:{([\w$]+)}|<([\w$]+)>|(\d\d?|[\s\S]))/g,p=void 0===t.exec.call(/()??/,"")[1],d=void 0!==/x/.flags,{toString:g}={};function f(e){let n=!0;try{new RegExp("",e)}catch(e){n=!1}return n}const h=f("u"),x=f("y"),y={g:!0,i:!0,m:!0,u:h,y:x};function w(n,t,r,a,l){if(n[e]={captureNames:t},l)return n;if(n.__proto__)n.__proto__=_.prototype;else for(const e in _.prototype)n[e]=_.prototype[e];return n[e].source=r,n[e].flags=a?a.split("").sort().join(""):a,n}function m(e){return t.replace.call(e,/([\s\S])(?=[\s\S]*\1)/g,"")}function E(n,r){if(!_.isRegExp(n))throw new TypeError("Type RegExp expected");const a=n[e]||{};let l=function(e){return d?e.flags:t.exec.call(/\/([a-z]*)$/i,RegExp.prototype.toString.call(e))[1]}(n),s="",o="",i=null,c=null;return(r=r||{}).removeG&&(o+="g"),r.removeY&&(o+="y"),o&&(l=t.replace.call(l,new RegExp(`[${o}]+`,"g"),"")),r.addG&&(s+="g"),r.addY&&(s+="y"),s&&(l=m(l+s)),r.isInternalOnly||(void 0!==a.source&&(i=a.source),null!=a.flags&&(c=s?m(a.flags+s):a.flags)),n=w(new RegExp(r.source||n.source,l),function(n){return!(!n[e]||!n[e].captureNames)}(n)?a.captureNames.slice(0):null,i,c,r.isInternalOnly)}function S(e){return parseInt(e,16)}function $(e,n,r){return"("===e.input[e.index-1]||")"===e.input[e.index+e[0].length]||"|"===e.input[e.index-1]||"|"===e.input[e.index+e[0].length]||e.index<1||e.index+e[0].length>=e.input.length||t.test.call(/^\(\?[:=!]/,e.input.substr(e.index-3,3))||function(e,n,r){return t.test.call(r.includes("x")?new RegExp("^(?:\\s|#[^#\\n]*|\\(\\?#[^)]*\\))*(?:[?*+]|{\\d+(?:,\\d*)?})"):new RegExp("^(?:\\(\\?#[^)]*\\))*(?:[?*+]|{\\d+(?:,\\d*)?})"),e.slice(n))}(e.input,e.index+e[0].length,r)?"":"(?:)"}function I(e){return parseInt(e,10).toString(16)}function k(e,n){return g.call(e)===`[object ${n}]`}function b(e){for(;e.length<4;)e=`0${e}`;return e}function N(e){const n={};return k(e,"String")?(_.forEach(e,/[^\s,]+/,e=>{n[e]=!0}),n):e}function v(e){if(!/^[\w$]$/.test(e))throw new Error("Flag must be a single character A-Za-z0-9_$");y[e]=!0}function C(e,n,t,r,a){let l=s.length;const o=e[t];let i,c,u=null;for(;l--;)if(!((c=s[l]).leadChar&&c.leadChar!==o||c.scope!==r&&"all"!==c.scope||c.flag&&!n.includes(c.flag))&&(i=_.exec(e,c.regex,t,"sticky"))){u={matchLength:i[0].length,output:c.handler.call(a,i,r,n),reparse:c.reparse};break}return u}function R(e){n.astral=e}function F(e){n.namespacing=e}function A(e){if(null==e)throw new TypeError("Cannot convert null or undefined to object");return e}function _(e,n){if(_.isRegExp(e)){if(void 0!==n)throw new TypeError("Cannot supply flags when copying a RegExp");return E(e)}if(e=void 0===e?"":String(e),n=void 0===n?"":String(n),_.isInstalled("astral")&&!n.includes("A")&&(n+="A"),l[e]||(l[e]={}),!l[e][n]){const r={hasNamedCapture:!1,captureNames:[]};let a,s=o,u="",p=0;const d=function(e,n){if(m(n)!==n)throw new SyntaxError(`Invalid duplicate regex flag ${n}`);e=t.replace.call(e,/^\(\?([\w$]+)\)/,(e,r)=>{if(t.test.call(/[gy]/,r))throw new SyntaxError(`Cannot use flag g or y in mode modifier ${e}`);return n=m(n+r),""});for(const e of n)if(!y[e])throw new SyntaxError(`Unknown regex flag ${e}`);return{pattern:e,flags:n}}(e,n);let g=d.pattern;const f=d.flags;for(;p<g.length;){do{(a=C(g,f,p,s,r))&&a.reparse&&(g=g.slice(0,p)+a.output+g.slice(p+a.matchLength))}while(a&&a.reparse);if(a)u+=a.output,p+=a.matchLength||1;else{const[e]=_.exec(g,c[s],p,"sticky");u+=e,p+=e.length,"["===e&&s===o?s=i:"]"===e&&s===i&&(s=o)}}l[e][n]={pattern:t.replace.call(u,/(?:\(\?:\))+/g,"(?:)"),flags:t.replace.call(f,/[^gimuy]+/g,""),captures:r.hasNamedCapture?r.captureNames:null}}const r=l[e][n];return w(new RegExp(r.pattern,r.flags),r.captures,e,n)}return _.prototype=new RegExp,_.version="4.2.4",_._clipDuplicates=m,_._hasNativeFlag=f,_._dec=S,_._hex=I,_._pad4=b,_.addToken=((e,n,r)=>{r=r||{};let{optionalFlags:a}=r;if(r.flag&&v(r.flag),a){a=t.split.call(a,"");for(const e of a)v(e)}s.push({regex:E(e,{addG:!0,addY:x,isInternalOnly:!0}),handler:n,scope:r.scope||o,flag:r.flag,reparse:r.reparse,leadChar:r.leadChar}),_.cache.flush("patterns")}),_.cache=((e,n)=>(a[e]||(a[e]={}),a[e][n]||(a[e][n]=_(e,n)))),_.cache.flush=(e=>{"patterns"===e?l={}:a={}}),_.escape=(e=>t.replace.call(A(e),/[-\[\]{}()*+?.,\\^$|#\s]/g,"\\$&")),_.exec=((n,t,a,l)=>{let s,o="g",i=!1,c=!1;(i=x&&!!(l||t.sticky&&!1!==l))?o+="y":l&&(c=!0,o+="FakeY"),t[e]=t[e]||{};const u=t[e][o]||(t[e][o]=E(t,{addG:!0,addY:i,source:c?`${t.source}|()`:void 0,removeY:!1===l,isInternalOnly:!0}));return a=a||0,u.lastIndex=a,s=r.exec.call(u,n),c&&s&&""===s.pop()&&(s=null),t.global&&(t.lastIndex=s?u.lastIndex:0),s}),_.forEach=((e,n,t)=>{let r,a=0,l=-1;for(;r=_.exec(e,n,a);)t(r,++l,e,n),a=r.index+(r[0].length||1)}),_.globalize=(e=>E(e,{addG:!0})),_.install=(e=>{e=N(e),!n.astral&&e.astral&&R(!0),!n.namespacing&&e.namespacing&&F(!0)}),_.isInstalled=(e=>!!n[e]),_.isRegExp=(e=>"[object RegExp]"===g.call(e)),_.match=((n,r,a)=>{const l=r.global&&"one"!==a||"all"===a,s=(l?"g":"")+(r.sticky?"y":"")||"noGY";r[e]=r[e]||{};const o=r[e][s]||(r[e][s]=E(r,{addG:!!l,removeG:"one"===a,isInternalOnly:!0})),i=t.match.call(A(n),o);return r.global&&(r.lastIndex="one"===a&&i?i.index+i[0].length:0),l?i||[]:i&&i[0]}),_.matchChain=((e,n)=>(function e(t,r){const a=n[r].regex?n[r]:{regex:n[r]},l=[];function s(e){if(a.backref){const n=`Backreference to undefined group: ${a.backref}`,t=isNaN(a.backref);if(t&&_.isInstalled("namespacing")){if(!(a.backref in e.groups))throw new ReferenceError(n)}else if(!e.hasOwnProperty(a.backref))throw new ReferenceError(n);const r=t&&_.isInstalled("namespacing")?e.groups[a.backref]:e[a.backref];l.push(r||"")}else l.push(e[0])}for(const e of t)_.forEach(e,a.regex,s);return r!==n.length-1&&l.length?e(l,r+1):l})([e],0)),_.replace=((n,t,a,l)=>{const s=_.isRegExp(t),o=t.global&&"one"!==l||"all"===l,i=(o?"g":"")+(t.sticky?"y":"")||"noGY";let c=t;s?(t[e]=t[e]||{},c=t[e][i]||(t[e][i]=E(t,{addG:!!o,removeG:"one"===l,isInternalOnly:!0}))):o&&(c=new RegExp(_.escape(String(t)),"g"));const u=r.replace.call(A(n),c,a);return s&&t.global&&(t.lastIndex=0),u}),_.replaceEach=((e,n)=>{for(const t of n)e=_.replace(e,t[0],t[1],t[2]);return e}),_.split=((e,n,t)=>r.split.call(A(e),n,t)),_.test=((e,n,t,r)=>!!_.exec(e,n,t,r)),_.uninstall=(e=>{e=N(e),n.astral&&e.astral&&R(!1),n.namespacing&&e.namespacing&&F(!1)}),_.union=((n,r,a)=>{const l=(a=a||{}).conjunction||"or";let s,o,i=0;function c(e,n,t){const r=o[i-s];if(n){if(++i,r)return`(?<${r}>`}else if(t)return`\\${+t+s}`;return e}if(!k(n,"Array")||!n.length)throw new TypeError("Must provide a nonempty array of patterns to merge");const u=/(\()(?!\?)|\\([1-9]\d*)|\\[\s\S]|\[(?:[^\\\]]|\\[\s\S])*\]/g,p=[];for(const r of n)_.isRegExp(r)?(s=i,o=r[e]&&r[e].captureNames||[],p.push(t.replace.call(_(r.source).source,u,c))):p.push(_.escape(r));const d="none"===l?"":"|";return _(p.join(d),r)}),r.exec=function(n){const r=this.lastIndex,a=t.exec.apply(this,arguments);if(a){if(!p&&a.length>1&&a.includes("")){const e=E(this,{removeG:!0,isInternalOnly:!0});t.replace.call(String(n).slice(a.index),e,(...e)=>{const n=e.length;for(let t=1;t<n-2;++t)void 0===e[t]&&(a[t]=void 0)})}let r=a;if(_.isInstalled("namespacing")&&(a.groups=Object.create(null),r=a.groups),this[e]&&this[e].captureNames)for(let n=1;n<a.length;++n){const t=this[e].captureNames[n-1];t&&(r[t]=a[n])}this.global&&!a[0].length&&this.lastIndex>a.index&&(this.lastIndex=a.index)}return this.global||(this.lastIndex=r),a},r.test=function(e){return!!r.exec.call(this,e)},r.match=function(e){if(_.isRegExp(e)){if(e.global){const n=t.match.apply(this,arguments);return e.lastIndex=0,n}}else e=new RegExp(e);return r.exec.call(e,A(this))},r.replace=function(n,r){const a=_.isRegExp(n);let l,s,o;return a?(n[e]&&({captureNames:s}=n[e]),l=n.lastIndex):n+="",o=k(r,"Function")?t.replace.call(String(this),n,(...e)=>{if(s){let n;_.isInstalled("namespacing")?(n=Object.create(null),e.push(n)):(e[0]=new String(e[0]),[n]=e);for(let t=0;t<s.length;++t)s[t]&&(n[s[t]]=e[t+1])}return a&&n.global&&(n.lastIndex=e[e.length-2]+e[0].length),r(...e)}):t.replace.call(null==this?this:String(this),n,(...e)=>{return t.replace.call(String(r),u,function(n,t,r,a){if(t=t||r){let r=+t;if(r<=e.length-3)return e[r]||"";if((r=s?s.indexOf(t):-1)<0)throw new SyntaxError(`Backreference to undefined group ${n}`);return e[r+1]||""}if("$"===a)return"$";if("&"===a||0==+a)return e[0];if("`"===a)return e[e.length-1].slice(0,e[e.length-2]);if("'"===a)return e[e.length-1].slice(e[e.length-2]+e[0].length);if(a=+a,!isNaN(a)){if(a>e.length-3)throw new SyntaxError(`Backreference to undefined group ${n}`);return e[a]||""}throw new SyntaxError(`Invalid token ${n}`)})}),a&&(n.global?n.lastIndex=0:n.lastIndex=l),o},r.split=function(e,n){if(!_.isRegExp(e))return t.split.apply(this,arguments);const r=String(this),a=[],l=e.lastIndex;let s,o=0;return n=(void 0===n?-1:n)>>>0,_.forEach(r,e,e=>{e.index+e[0].length>o&&(a.push(r.slice(o,e.index)),e.length>1&&e.index<r.length&&Array.prototype.push.apply(a,e.slice(1)),s=e[0].length,o=e.index+s)}),o===r.length?t.test.call(e,"")&&!s||a.push(""):a.push(r.slice(o)),e.lastIndex=l,a.length>n?a.slice(0,n):a},_.addToken(/\\([ABCE-RTUVXYZaeg-mopqyz]|c(?![A-Za-z])|u(?![\dA-Fa-f]{4}|{[\dA-Fa-f]+})|x(?![\dA-Fa-f]{2}))/,(e,n)=>{if("B"===e[1]&&n===o)return e[0];throw new SyntaxError(`Invalid escape ${e[0]}`)},{scope:"all",leadChar:"\\"}),_.addToken(/\\u{([\dA-Fa-f]+)}/,(e,n,t)=>{const r=S(e[1]);if(r>1114111)throw new SyntaxError(`Invalid Unicode code point ${e[0]}`);if(r<=65535)return`\\u${b(I(r))}`;if(h&&t.includes("u"))return e[0];throw new SyntaxError("Cannot use Unicode code point above \\u{FFFF} without flag u")},{scope:"all",leadChar:"\\"}),_.addToken(/\[(\^?)\]/,e=>e[1]?"[\\s\\S]":"\\b\\B",{leadChar:"["}),_.addToken(/\(\?#[^)]*\)/,$,{leadChar:"("}),_.addToken(/\s+|#[^\n]*\n?/,$,{flag:"x"}),_.addToken(/\./,()=>"[\\s\\S]",{flag:"s",leadChar:"."}),_.addToken(/\\k<([\w$]+)>/,function(e){const n=isNaN(e[1])?this.captureNames.indexOf(e[1])+1:+e[1],t=e.index+e[0].length;if(!n||n>this.captureNames.length)throw new SyntaxError(`Backreference to undefined group ${e[0]}`);return`\\${n}${t===e.input.length||isNaN(e.input[t])?"":"(?:)"}`},{leadChar:"\\"}),_.addToken(/\\(\d+)/,function(e,n){if(!(n===o&&/^[1-9]/.test(e[1])&&+e[1]<=this.captureNames.length)&&"0"!==e[1])throw new SyntaxError(`Cannot use octal escape or backreference to undefined group ${e[0]}`);return e[0]},{scope:"all",leadChar:"\\"}),_.addToken(/\(\?P?<([\w$]+)>/,function(e){if(!isNaN(e[1]))throw new SyntaxError(`Cannot use integer as capture name ${e[0]}`);if(!_.isInstalled("namespacing")&&("length"===e[1]||"__proto__"===e[1]))throw new SyntaxError(`Cannot use reserved word as capture name ${e[0]}`);if(this.captureNames.includes(e[1]))throw new SyntaxError(`Cannot use same name for multiple groups ${e[0]}`);return this.captureNames.push(e[1]),this.hasNamedCapture=!0,"("},{leadChar:"("}),_.addToken(/\((?!\?)/,function(e,n,t){return t.includes("n")?"(?:":(this.captureNames.push(null),"(")},{optionalFlags:"n",leadChar:"("}),_});
//# sourceMappingURL=sourcemaps/XRegExp.js.map
