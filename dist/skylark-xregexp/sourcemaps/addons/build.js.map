{"version":3,"sources":["addons/build.js"],"names":["define","XRegExp","REGEX_DATA","subParts","parts","union","conjunction","deanchor","pattern","leadingAnchor","trailingAnchor","test","replace","asXRegExp","value","addFlagX","flags","isRegExp","captureNames","source","interpolate","substitution","RegExp","escape","reduceToSubpatternsObject","subpatterns","interpolated","subpatternIndex","embedSubpatternAfter","raw","rawLiterals","length","tag","literals","substitutions","map","reduce","join","build","subs","includes","inlineFlags","exec","_clipDuplicates","data","p","hasOwnProperty","sub","names","patternAsRegex","numPriorCaps","numCaps","numOuterCaps","outerCapsMap","outerCapNames","output","$0","$1","$2","$3","$4","subName","capName","intro","localCapIndex","ReferenceError","match","paren","backref"],"mappings":";;;;;;;AAKAA,UAAU,WACN,OAAQC,IACJ,MAAMC,EAAa,UACbC,EAAW,8DACXC,EAAQH,EAAQI,OAAO,gCAAiCF,GAAW,KACrEG,YAAa,OAUjB,SAASC,EAASC,GAGd,MAAMC,EAAgB,kBAChBC,EAAiB,kBAEvB,OACID,EAAcE,KAAKH,IACnBE,EAAeC,KAAKH,IAEpBE,EAAeC,KAAKH,EAAQI,QAAQ,YAAa,KAE1CJ,EAAQI,QAAQH,EAAe,IAAIG,QAAQF,EAAgB,IAG/DF,EAYX,SAASK,EAAUC,EAAOC,GACtB,MAAMC,EAAQD,EAAW,IAAM,GAC/B,OAAOd,EAAQgB,SAASH,GACnBA,EAAMZ,IAAeY,EAAMZ,GAAYgB,aAEpCJ,EAEAb,EAAQa,EAAMK,OAAQH,GAG1Bf,EAAQa,EAAOE,GAGvB,SAASI,EAAYC,GACjB,OAAOA,aAAwBC,OAASD,EAAepB,EAAQsB,OAAOF,GAG1E,SAASG,EAA0BC,EAAaC,EAAcC,GAE1D,OADAF,eAAyBE,KAAqBD,EACvCD,EAGX,SAASG,EAAqBC,EAAKF,EAAiBG,GAEhD,OAAOD,GADeF,EAAkBG,EAAYC,OAAS,iBAChBJ,MAAsB,IA2BvE1B,EAAQ+B,IAAM,CAAChB,GAAU,CAACiB,KAAaC,KACnC,MAAMT,EAAcS,EAAcC,IAAIf,GAAagB,OAAOZ,MACpDhB,EAAUyB,EAASJ,IAAIM,IAAIP,GAAsBS,KAAK,IAC5D,OAAOpC,EAAQqC,MAAM9B,EAASiB,EAAaT,KA4B/Cf,EAAQqC,MAAQ,EAAC9B,EAAS+B,EAAMvB,KAK5B,MAAMD,GAJNC,EAAQA,GAAS,IAIMwB,SAAS,KAC1BC,EAAc,kBAAkBC,KAAKlC,GAEvCiC,IACAzB,EAAQf,EAAQ0C,gBAAgB3B,EAAQyB,EAAY,KAGxD,MAAMG,KACN,IAAK,MAAMC,KAAKN,EACZ,GAAIA,EAAKO,eAAeD,GAAI,CAKxB,MAAME,EAAMlC,EAAU0B,EAAKM,GAAI9B,GAC/B6B,EAAKC,IAGDrC,QAASD,EAASwC,EAAI5B,QACtB6B,MAAOD,EAAI7C,GAAYgB,kBAOnC,MAAM+B,EAAiBpC,EAAUL,EAASO,GAG1C,IACImC,EADAC,EAAU,EAEVC,EAAe,EACnB,MAAMC,GAAgB,GAChBC,EAAgBL,EAAe/C,GAAYgB,iBAC3CqC,EAASN,EAAe9B,OAAOP,QAAQR,EAAO,CAACoD,EAAIC,EAAIC,EAAIC,EAAIC,KACjE,MAAMC,EAAUJ,GAAMC,EACtB,IAAII,EACAC,EACAC,EAEJ,GAAIH,EAAS,CACT,IAAKjB,EAAKE,eAAee,GACrB,MAAM,IAAII,qCAAqCT,KAiCnD,OA9BIC,GACAK,EAAUR,EAAcF,GACxBC,IAAeD,KAAkBD,EAGjCY,QAAcD,GAAWD,MAEzBE,EAAQ,MAEZb,EAAeC,KAqBLY,IApBkBnB,EAAKiB,GAASrD,QAAQI,QAAQT,EAAU,CAAC+D,EAAOC,EAAOC,KAE/E,GAAID,GAIA,GAHAL,EAAUlB,EAAKiB,GAASb,MAAMG,EAAUD,KACtCC,EAEEW,EACA,YAAaA,UAGd,GAAIM,EAGP,OAFAJ,GAAiBI,EAAU,EAEpBxB,EAAKiB,GAASb,MAAMgB,UAEhBpB,EAAKiB,GAASb,MAAMgB,YACrBI,EAAUlB,IAExB,OAAOgB,OAKf,GAAIP,GAIA,GAHAG,EAAUR,EAAcF,GACxBC,IAAeD,KAAkBD,EAE7BW,EACA,YAAaA,UAGd,GAAIF,EAGP,OAAON,EAFPU,GAAiBJ,EAAK,UAIXN,EAAcU,WAChBX,GAAcO,KAE3B,OAAOJ,IAGX,OAAOvD,EAAQsD,EAAQvC","file":"../../addons/build.js","sourcesContent":["/*!\n * XRegExp.build 4.2.4\n * <xregexp.com>\n * Steven Levithan (c) 2012-present MIT License\n */\ndefine([],function(){\n    return (XRegExp) => {\n        const REGEX_DATA = 'xregexp';\n        const subParts = /(\\()(?!\\?)|\\\\([1-9]\\d*)|\\\\[\\s\\S]|\\[(?:[^\\\\\\]]|\\\\[\\s\\S])*\\]/g;\n        const parts = XRegExp.union([/\\({{([\\w$]+)}}\\)|{{([\\w$]+)}}/, subParts], 'g', {\n            conjunction: 'or'\n        });\n\n        /**\n         * Strips a leading `^` and trailing unescaped `$`, if both are present.\n         *\n         * @private\n         * @param {String} pattern Pattern to process.\n         * @returns {String} Pattern with edge anchors removed.\n         */\n        function deanchor(pattern) {\n            // Allow any number of empty noncapturing groups before/after anchors, because regexes\n            // built/generated by XRegExp sometimes include them\n            const leadingAnchor = /^(?:\\(\\?:\\))*\\^/;\n            const trailingAnchor = /\\$(?:\\(\\?:\\))*$/;\n\n            if (\n                leadingAnchor.test(pattern) &&\n                trailingAnchor.test(pattern) &&\n                // Ensure that the trailing `$` isn't escaped\n                trailingAnchor.test(pattern.replace(/\\\\[\\s\\S]/g, ''))\n            ) {\n                return pattern.replace(leadingAnchor, '').replace(trailingAnchor, '');\n            }\n\n            return pattern;\n        }\n\n        /**\n         * Converts the provided value to an XRegExp. Native RegExp flags are not preserved.\n         *\n         * @private\n         * @param {String|RegExp} value Value to convert.\n         * @param {Boolean} [addFlagX] Whether to apply the `x` flag in cases when `value` is not\n         *   already a regex generated by XRegExp\n         * @returns {RegExp} XRegExp object with XRegExp syntax applied.\n         */\n        function asXRegExp(value, addFlagX) {\n            const flags = addFlagX ? 'x' : '';\n            return XRegExp.isRegExp(value) ?\n                (value[REGEX_DATA] && value[REGEX_DATA].captureNames ?\n                    // Don't recompile, to preserve capture names\n                    value :\n                    // Recompile as XRegExp\n                    XRegExp(value.source, flags)\n                ) :\n                // Compile string as XRegExp\n                XRegExp(value, flags);\n        }\n\n        function interpolate(substitution) {\n            return substitution instanceof RegExp ? substitution : XRegExp.escape(substitution);\n        }\n\n        function reduceToSubpatternsObject(subpatterns, interpolated, subpatternIndex) {\n            subpatterns[`subpattern${subpatternIndex}`] = interpolated;\n            return subpatterns;\n        }\n\n        function embedSubpatternAfter(raw, subpatternIndex, rawLiterals) {\n            const hasSubpattern = subpatternIndex < rawLiterals.length - 1;\n            return raw + (hasSubpattern ? `{{subpattern${subpatternIndex}}}` : '');\n        }\n\n        /**\n         * Provides tagged template literals that create regexes with XRegExp syntax and flags. The\n         * provided pattern is handled as a raw string, so backslashes don't need to be escaped.\n         *\n         * Interpolation of strings and regexes shares the features of `XRegExp.build`. Interpolated\n         * patterns are treated as atomic units when quantified, interpolated strings have their special\n         * characters escaped, a leading `^` and trailing unescaped `$` are stripped from interpolated\n         * regexes if both are present, and any backreferences within an interpolated regex are\n         * rewritten to work within the overall pattern.\n         *\n         * @memberOf XRegExp\n         * @param {String} [flags] Any combination of XRegExp flags.\n         * @returns {Function} Handler for template literals that construct regexes with XRegExp syntax.\n         * @example\n         *\n         * const h12 = /1[0-2]|0?[1-9]/;\n         * const h24 = /2[0-3]|[01][0-9]/;\n         * const hours = XRegExp.tag('x')`${h12} : | ${h24}`;\n         * const minutes = /^[0-5][0-9]$/;\n         * // Note that explicitly naming the 'minutes' group is required for named backreferences\n         * const time = XRegExp.tag('x')`^ ${hours} (?<minutes>${minutes}) $`;\n         * time.test('10:59'); // -> true\n         * XRegExp.exec('10:59', time).minutes; // -> '59'\n         */\n        XRegExp.tag = (flags) => (literals, ...substitutions) => {\n            const subpatterns = substitutions.map(interpolate).reduce(reduceToSubpatternsObject, {});\n            const pattern = literals.raw.map(embedSubpatternAfter).join('');\n            return XRegExp.build(pattern, subpatterns, flags);\n        };\n\n        /**\n         * Builds regexes using named subpatterns, for readability and pattern reuse. Backreferences in\n         * the outer pattern and provided subpatterns are automatically renumbered to work correctly.\n         * Native flags used by provided subpatterns are ignored in favor of the `flags` argument.\n         *\n         * @memberOf XRegExp\n         * @param {String} pattern XRegExp pattern using `{{name}}` for embedded subpatterns. Allows\n         *   `({{name}})` as shorthand for `(?<name>{{name}})`. Patterns cannot be embedded within\n         *   character classes.\n         * @param {Object} subs Lookup object for named subpatterns. Values can be strings or regexes. A\n         *   leading `^` and trailing unescaped `$` are stripped from subpatterns, if both are present.\n         * @param {String} [flags] Any combination of XRegExp flags.\n         * @returns {RegExp} Regex with interpolated subpatterns.\n         * @example\n         *\n         * const time = XRegExp.build('(?x)^ {{hours}} ({{minutes}}) $', {\n         *   hours: XRegExp.build('{{h12}} : | {{h24}}', {\n         *     h12: /1[0-2]|0?[1-9]/,\n         *     h24: /2[0-3]|[01][0-9]/\n         *   }, 'x'),\n         *   minutes: /^[0-5][0-9]$/\n         * });\n         * time.test('10:59'); // -> true\n         * XRegExp.exec('10:59', time).minutes; // -> '59'\n         */\n        XRegExp.build = (pattern, subs, flags) => {\n            flags = flags || '';\n            // Used with `asXRegExp` calls for `pattern` and subpatterns in `subs`, to work around how\n            // some browsers convert `RegExp('\\n')` to a regex that contains the literal characters `\\`\n            // and `n`. See more details at <https://github.com/slevithan/xregexp/pull/163>.\n            const addFlagX = flags.includes('x');\n            const inlineFlags = /^\\(\\?([\\w$]+)\\)/.exec(pattern);\n            // Add flags within a leading mode modifier to the overall pattern's flags\n            if (inlineFlags) {\n                flags = XRegExp._clipDuplicates(flags + inlineFlags[1]);\n            }\n\n            const data = {};\n            for (const p in subs) {\n                if (subs.hasOwnProperty(p)) {\n                    // Passing to XRegExp enables extended syntax and ensures independent validity,\n                    // lest an unescaped `(`, `)`, `[`, or trailing `\\` breaks the `(?:)` wrapper. For\n                    // subpatterns provided as native regexes, it dies on octals and adds the property\n                    // used to hold extended regex instance data, for simplicity.\n                    const sub = asXRegExp(subs[p], addFlagX);\n                    data[p] = {\n                        // Deanchoring allows embedding independently useful anchored regexes. If you\n                        // really need to keep your anchors, double them (i.e., `^^...$$`).\n                        pattern: deanchor(sub.source),\n                        names: sub[REGEX_DATA].captureNames || []\n                    };\n                }\n            }\n\n            // Passing to XRegExp dies on octals and ensures the outer pattern is independently valid;\n            // helps keep this simple. Named captures will be put back.\n            const patternAsRegex = asXRegExp(pattern, addFlagX);\n\n            // 'Caps' is short for 'captures'\n            let numCaps = 0;\n            let numPriorCaps;\n            let numOuterCaps = 0;\n            const outerCapsMap = [0];\n            const outerCapNames = patternAsRegex[REGEX_DATA].captureNames || [];\n            const output = patternAsRegex.source.replace(parts, ($0, $1, $2, $3, $4) => {\n                const subName = $1 || $2;\n                let capName;\n                let intro;\n                let localCapIndex;\n                // Named subpattern\n                if (subName) {\n                    if (!data.hasOwnProperty(subName)) {\n                        throw new ReferenceError(`Undefined property ${$0}`);\n                    }\n                    // Named subpattern was wrapped in a capturing group\n                    if ($1) {\n                        capName = outerCapNames[numOuterCaps];\n                        outerCapsMap[++numOuterCaps] = ++numCaps;\n                        // If it's a named group, preserve the name. Otherwise, use the subpattern name\n                        // as the capture name\n                        intro = `(?<${capName || subName}>`;\n                    } else {\n                        intro = '(?:';\n                    }\n                    numPriorCaps = numCaps;\n                    const rewrittenSubpattern = data[subName].pattern.replace(subParts, (match, paren, backref) => {\n                        // Capturing group\n                        if (paren) {\n                            capName = data[subName].names[numCaps - numPriorCaps];\n                            ++numCaps;\n                            // If the current capture has a name, preserve the name\n                            if (capName) {\n                                return `(?<${capName}>`;\n                            }\n                        // Backreference\n                        } else if (backref) {\n                            localCapIndex = +backref - 1;\n                            // Rewrite the backreference\n                            return data[subName].names[localCapIndex] ?\n                                // Need to preserve the backreference name in case using flag `n`\n                                `\\\\k<${data[subName].names[localCapIndex]}>` :\n                                `\\\\${+backref + numPriorCaps}`;\n                        }\n                        return match;\n                    });\n                    return `${intro}${rewrittenSubpattern})`;\n                }\n                // Capturing group\n                if ($3) {\n                    capName = outerCapNames[numOuterCaps];\n                    outerCapsMap[++numOuterCaps] = ++numCaps;\n                    // If the current capture has a name, preserve the name\n                    if (capName) {\n                        return `(?<${capName}>`;\n                    }\n                // Backreference\n                } else if ($4) {\n                    localCapIndex = +$4 - 1;\n                    // Rewrite the backreference\n                    return outerCapNames[localCapIndex] ?\n                        // Need to preserve the backreference name in case using flag `n`\n                        `\\\\k<${outerCapNames[localCapIndex]}>` :\n                        `\\\\${outerCapsMap[+$4]}`;\n                }\n                return $0;\n            });\n\n            return XRegExp(output, flags);\n        };\n    };\n});\n"]}