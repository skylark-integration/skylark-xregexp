{"version":3,"sources":["addons/unicode-base.js"],"names":["define","XRegExp","unicode","dec","_dec","hex","_hex","pad4","_pad4","normalize","name","replace","toLowerCase","charCode","chr","esc","exec","charCodeAt","cacheInvertedBmp","slug","range","output","lastEnd","forEach","m","start","invertBmp","bmp","cacheAstral","isNegated","prop","item","combined","isBmpLast","astral","buildAstral","addToken","match","scope","flags","isAstralMode","includes","SyntaxError","hasOwnProperty","inverseOf","ReferenceError","optionalFlags","leadChar","addUnicodeData","data","Error","alias","cache","flush","_getUnicodeProperty"],"mappings":"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","file":"../../addons/unicode-base.js","sourcesContent":["/*!\n * XRegExp Unicode Base 4.2.4\n * <xregexp.com>\n * Steven Levithan (c) 2008-present MIT License\n */\ndefine([],function(){\n    return (XRegExp) => {\n\n        /**\n         * Adds base support for Unicode matching:\n         * - Adds syntax `\\p{..}` for matching Unicode tokens. Tokens can be inverted using `\\P{..}` or\n         *   `\\p{^..}`. Token names ignore case, spaces, hyphens, and underscores. You can omit the\n         *   braces for token names that are a single letter (e.g. `\\pL` or `PL`).\n         * - Adds flag A (astral), which enables 21-bit Unicode support.\n         * - Adds the `XRegExp.addUnicodeData` method used by other addons to provide character data.\n         *\n         * Unicode Base relies on externally provided Unicode character data. Official addons are\n         * available to provide data for Unicode categories, scripts, blocks, and properties.\n         *\n         * @requires XRegExp\n         */\n\n        // ==--------------------------==\n        // Private stuff\n        // ==--------------------------==\n\n        // Storage for Unicode data\n        const unicode = {};\n\n        // Reuse utils\n        const dec = XRegExp._dec;\n        const hex = XRegExp._hex;\n        const pad4 = XRegExp._pad4;\n\n        // Generates a token lookup name: lowercase, with hyphens, spaces, and underscores removed\n        function normalize(name) {\n            return name.replace(/[- _]+/g, '').toLowerCase();\n        }\n\n        // Gets the decimal code of a literal code unit, \\xHH, \\uHHHH, or a backslash-escaped literal\n        function charCode(chr) {\n            const esc = /^\\\\[xu](.+)/.exec(chr);\n            return esc ?\n                dec(esc[1]) :\n                chr.charCodeAt(chr[0] === '\\\\' ? 1 : 0);\n        }\n\n        // Inverts a list of ordered BMP characters and ranges\n        function invertBmp(range) {\n            let output = '';\n            let lastEnd = -1;\n\n            XRegExp.forEach(\n                range,\n                /(\\\\x..|\\\\u....|\\\\?[\\s\\S])(?:-(\\\\x..|\\\\u....|\\\\?[\\s\\S]))?/,\n                (m) => {\n                    const start = charCode(m[1]);\n                    if (start > (lastEnd + 1)) {\n                        output += `\\\\u${pad4(hex(lastEnd + 1))}`;\n                        if (start > (lastEnd + 2)) {\n                            output += `-\\\\u${pad4(hex(start - 1))}`;\n                        }\n                    }\n                    lastEnd = charCode(m[2] || m[1]);\n                }\n            );\n\n            if (lastEnd < 0xFFFF) {\n                output += `\\\\u${pad4(hex(lastEnd + 1))}`;\n                if (lastEnd < 0xFFFE) {\n                    output += '-\\\\uFFFF';\n                }\n            }\n\n            return output;\n        }\n\n        // Generates an inverted BMP range on first use\n        function cacheInvertedBmp(slug) {\n            const prop = 'b!';\n            return (\n                unicode[slug][prop] ||\n                (unicode[slug][prop] = invertBmp(unicode[slug].bmp))\n            );\n        }\n\n        // Combines and optionally negates BMP and astral data\n        function buildAstral(slug, isNegated) {\n            const item = unicode[slug];\n            let combined = '';\n\n            if (item.bmp && !item.isBmpLast) {\n                combined = `[${item.bmp}]${item.astral ? '|' : ''}`;\n            }\n            if (item.astral) {\n                combined += item.astral;\n            }\n            if (item.isBmpLast && item.bmp) {\n                combined += `${item.astral ? '|' : ''}[${item.bmp}]`;\n            }\n\n            // Astral Unicode tokens always match a code point, never a code unit\n            return isNegated ?\n                `(?:(?!${combined})(?:[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\0-\\uFFFF]))` :\n                `(?:${combined})`;\n        }\n\n        // Builds a complete astral pattern on first use\n        function cacheAstral(slug, isNegated) {\n            const prop = isNegated ? 'a!' : 'a=';\n            return (\n                unicode[slug][prop] ||\n                (unicode[slug][prop] = buildAstral(slug, isNegated))\n            );\n        }\n\n        // ==--------------------------==\n        // Core functionality\n        // ==--------------------------==\n\n        /*\n         * Add astral mode (flag A) and Unicode token syntax: `\\p{..}`, `\\P{..}`, `\\p{^..}`, `\\pC`.\n         */\n        XRegExp.addToken(\n            // Use `*` instead of `+` to avoid capturing `^` as the token name in `\\p{^}`\n            /\\\\([pP])(?:{(\\^?)([^}]*)}|([A-Za-z]))/,\n            (match, scope, flags) => {\n                const ERR_DOUBLE_NEG = 'Invalid double negation ';\n                const ERR_UNKNOWN_NAME = 'Unknown Unicode token ';\n                const ERR_UNKNOWN_REF = 'Unicode token missing data ';\n                const ERR_ASTRAL_ONLY = 'Astral mode required for Unicode token ';\n                const ERR_ASTRAL_IN_CLASS = 'Astral mode does not support Unicode tokens within character classes';\n                // Negated via \\P{..} or \\p{^..}\n                let isNegated = match[1] === 'P' || !!match[2];\n                // Switch from BMP (0-FFFF) to astral (0-10FFFF) mode via flag A\n                const isAstralMode = flags.includes('A');\n                // Token lookup name. Check `[4]` first to avoid passing `undefined` via `\\p{}`\n                let slug = normalize(match[4] || match[3]);\n                // Token data object\n                let item = unicode[slug];\n\n                if (match[1] === 'P' && match[2]) {\n                    throw new SyntaxError(ERR_DOUBLE_NEG + match[0]);\n                }\n                if (!unicode.hasOwnProperty(slug)) {\n                    throw new SyntaxError(ERR_UNKNOWN_NAME + match[0]);\n                }\n\n                // Switch to the negated form of the referenced Unicode token\n                if (item.inverseOf) {\n                    slug = normalize(item.inverseOf);\n                    if (!unicode.hasOwnProperty(slug)) {\n                        throw new ReferenceError(`${ERR_UNKNOWN_REF + match[0]} -> ${item.inverseOf}`);\n                    }\n                    item = unicode[slug];\n                    isNegated = !isNegated;\n                }\n\n                if (!(item.bmp || isAstralMode)) {\n                    throw new SyntaxError(ERR_ASTRAL_ONLY + match[0]);\n                }\n                if (isAstralMode) {\n                    if (scope === 'class') {\n                        throw new SyntaxError(ERR_ASTRAL_IN_CLASS);\n                    }\n\n                    return cacheAstral(slug, isNegated);\n                }\n\n                return scope === 'class' ?\n                    (isNegated ? cacheInvertedBmp(slug) : item.bmp) :\n                    `${(isNegated ? '[^' : '[') + item.bmp}]`;\n            },\n            {\n                scope: 'all',\n                optionalFlags: 'A',\n                leadChar: '\\\\'\n            }\n        );\n\n        /**\n         * Adds to the list of Unicode tokens that XRegExp regexes can match via `\\p` or `\\P`.\n         *\n         * @memberOf XRegExp\n         * @param {Array} data Objects with named character ranges. Each object may have properties\n         *   `name`, `alias`, `isBmpLast`, `inverseOf`, `bmp`, and `astral`. All but `name` are\n         *   optional, although one of `bmp` or `astral` is required (unless `inverseOf` is set). If\n         *   `astral` is absent, the `bmp` data is used for BMP and astral modes. If `bmp` is absent,\n         *   the name errors in BMP mode but works in astral mode. If both `bmp` and `astral` are\n         *   provided, the `bmp` data only is used in BMP mode, and the combination of `bmp` and\n         *   `astral` data is used in astral mode. `isBmpLast` is needed when a token matches orphan\n         *   high surrogates *and* uses surrogate pairs to match astral code points. The `bmp` and\n         *   `astral` data should be a combination of literal characters and `\\xHH` or `\\uHHHH` escape\n         *   sequences, with hyphens to create ranges. Any regex metacharacters in the data should be\n         *   escaped, apart from range-creating hyphens. The `astral` data can additionally use\n         *   character classes and alternation, and should use surrogate pairs to represent astral code\n         *   points. `inverseOf` can be used to avoid duplicating character data if a Unicode token is\n         *   defined as the exact inverse of another token.\n         * @example\n         *\n         * // Basic use\n         * XRegExp.addUnicodeData([{\n         *   name: 'XDigit',\n         *   alias: 'Hexadecimal',\n         *   bmp: '0-9A-Fa-f'\n         * }]);\n         * XRegExp('\\\\p{XDigit}:\\\\p{Hexadecimal}+').test('0:3D'); // -> true\n         */\n        XRegExp.addUnicodeData = (data) => {\n            const ERR_NO_NAME = 'Unicode token requires name';\n            const ERR_NO_DATA = 'Unicode token has no character data ';\n\n            for (const item of data) {\n                if (!item.name) {\n                    throw new Error(ERR_NO_NAME);\n                }\n                if (!(item.inverseOf || item.bmp || item.astral)) {\n                    throw new Error(ERR_NO_DATA + item.name);\n                }\n                unicode[normalize(item.name)] = item;\n                if (item.alias) {\n                    unicode[normalize(item.alias)] = item;\n                }\n            }\n\n            // Reset the pattern cache used by the `XRegExp` constructor, since the same pattern and\n            // flags might now produce different results\n            XRegExp.cache.flush('patterns');\n        };\n\n        /**\n         * @ignore\n         *\n         * Return a reference to the internal Unicode definition structure for the given Unicode\n         * Property if the given name is a legal Unicode Property for use in XRegExp `\\p` or `\\P` regex\n         * constructs.\n         *\n         * @memberOf XRegExp\n         * @param {String} name Name by which the Unicode Property may be recognized (case-insensitive),\n         *   e.g. `'N'` or `'Number'`. The given name is matched against all registered Unicode\n         *   Properties and Property Aliases.\n         * @returns {Object} Reference to definition structure when the name matches a Unicode Property.\n         *\n         * @note\n         * For more info on Unicode Properties, see also http://unicode.org/reports/tr18/#Categories.\n         *\n         * @note\n         * This method is *not* part of the officially documented API and may change or be removed in\n         * the future. It is meant for userland code that wishes to reuse the (large) internal Unicode\n         * structures set up by XRegExp.\n         */\n        XRegExp._getUnicodeProperty = (name) => {\n            const slug = normalize(name);\n            return unicode[slug];\n        };\n    };\n});"]}